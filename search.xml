<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python 管理 —— 包管理</title>
    <url>/archives/Python-%E7%AE%A1%E7%90%86-%E2%80%94%E2%80%94-%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>
<p>老规矩，在文章开始之前先简单罗列一下基本环境：</p>
<ul>
<li>操作系统（OS）：Ventura 13.4</li>
<li>Python 版本：3.11.3</li>
<li>pip 版本：23.1.2</li>
</ul>
<p>Pyhton 的强大来源于其丰富的第三方库，自然在使用 Python 的时候不可避免的会需要用到一些第三方库，那么，如何高效地对这些第三方库进行查找、安装和卸载等等操作，都是包管理涉及的内容。</p>
<p>pip 是官方提供给的一个 Python 包管理工具<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，pip 提供了对 Python 包进行的查找、下载、安装以及卸载等功能。下面要介绍的 Python 包管理的内容，也是围绕着 pip 工具展开的。</p>
<h2 id="pip-的安装">pip 的安装</h2>
<blockquote>
<p>注意：一般情况下，如果是从官网 <a href="https://www.python.org/">Python.org</a> 下载的 Python 会默认安装 pip.</p>
</blockquote>
<p>利用 Python 下载时自带的 <code>ensurepip</code> 模块，可以对 pip 进行安装：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m ensurepip --upgrade</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>python</code>：Python 的解释器，默认使用的解释器是 <code>CPython</code>，用 <code>&gt;&gt;&gt;</code> 作为提示符<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p></li>
<li><p><code>-m ensurepip</code>：在 <code>sys.path</code> 下搜索 <code>ensurepip</code> 的模块，并把相应的 <code>.py</code> 文件作为脚本运行，<code>--upgrade</code> 作为 <code>ensurepip</code> 的模块的参数</p>
<ul>
<li><p><code>sys.path</code>：模块的搜索路径，可以通过在 Python 的交互环境中 <code>import sys</code>，将 <code>sys.path</code> 打印出来<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">''</span>, <span class="string">'/usr/local/Cellar/python@3.11/3.11.3/Frameworks/Python.framework/Versions/3.11/lib/python311.zip'</span>, <span class="string">'/usr/local/Cellar/python@3.11/3.11.3/Frameworks/Python.framework/Versions/3.11/lib/python3.11'</span>, <span class="string">'/usr/local/Cellar/python@3.11/3.11.3/Frameworks/Python.framework/Versions/3.11/lib/python3.11/lib-dynload'</span>, <span class="string">'/usr/local/lib/python3.11/site-packages'</span>]</span><br></pre></td></tr></tbody></table></figure></li>
</ul></li>
</ul>
<p>可以简单看一下 <code>ensurepip</code> 模块的内容，发现 <code>ensurepip</code> 模块其实是一个文件夹：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/Cellar/python@3.11/3.11.3/Frameworks/Python.framework/Versions/3.11/lib/python3.11/ &amp;&amp; <span class="built_in">ls</span> -l | grep -i ensurepip</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">drwxr-xr-x    7 borne  admin     224  4 22 20:16 ensurepip</span><br></pre></td></tr></tbody></table></figure>
<p>通过 <code>tree</code> 命令查看 <code>ensurepip</code> 文件目录：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">tree ensurepip</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ensurepip</span><br><span class="line">├── __init__.py</span><br><span class="line">├── __main__.py</span><br><span class="line">├── __pycache__</span><br><span class="line">│&nbsp;&nbsp; ├── __init__.cpython-311.pyc</span><br><span class="line">│&nbsp;&nbsp; └── __main__.cpython-311.pyc</span><br><span class="line">├── _bundled</span><br><span class="line">│&nbsp;&nbsp; ├── pip-23.0.1-py3-none-any.whl</span><br><span class="line">│&nbsp;&nbsp; └── setuptools-67.6.1-py3-none-any.whl</span><br><span class="line">└── _uninstall.py</span><br></pre></td></tr></tbody></table></figure>
<p>进一步发现，由于 <code>__init__.py</code> 标识文件的存在，<code>ensurepip</code> 其实更确切的说是一个包（Package）。</p>
<p>通过 <code>cat</code> 命令，查看一下 <code>__init__.py</code> 文件：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ensurepip/__init__.py | more</span><br></pre></td></tr></tbody></table></figure>
<p>其中，有这样一段代码：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">parser = argparse.ArgumentParser(prog=<span class="string">"python -m ensurepip"</span>)</span><br><span class="line">parser.add_argument(</span><br><span class="line">        <span class="string">"-U"</span>, <span class="string">"--upgrade"</span>,</span><br><span class="line">        action=<span class="string">"store_true"</span>,</span><br><span class="line">        default=<span class="literal">False</span>,</span><br><span class="line">        <span class="built_in">help</span>=<span class="string">"Upgrade pip and dependencies, even if already installed."</span>,</span><br><span class="line">    )</span><br></pre></td></tr></tbody></table></figure>
<p>这就解释了，为什么可以通过 <code>python -m ensurepip --upgrade</code> 安装 pip.</p>
<p>关于 pip 的安装，还有最后一点需要强调的是，一个版本的 Python 对应了一个 pip 工具，理解这一点，对于电脑中存在多个版本的 Python 时尤其的重要，每个 Python 都有自己的 pip 工具，所以，当在使用 pip 工具安装第三方库时，一定要清楚，你当时使用的 pip 属于哪个版本的 Python（这个问题本质上是电脑的环境变量的配置问题），其实这也侧面体现出后面要介绍的 Python 版本管理 和 环境管理的意义和重要性。</p>
<p>如果不清楚当前的 pip 命令属于哪个版本的 Python，可以用 <code>which</code> 或 <code>whereis</code> 命令，再结合 <code>ls -l</code> 命令简单查询一下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> pip3</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">/usr/local/bin/pip3</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /usr/local/bin/pip3</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">lrwxr-xr-x  1 borne  admin  37  4 22 20:16 /usr/local/bin/pip3 -&gt; ../Cellar/python@3.11/3.11.3/bin/pip3</span><br></pre></td></tr></tbody></table></figure>
<p>从上面的结果可以看出，这里的 <code>pip3</code> 对应的是 <code>python@3.11</code>，所以，通过 <code>pip3</code> 安装的第三方库，其实是安装到了 <code>python@3.11</code> 的 <code>site-packages</code> 下。</p>
<h2 id="pip-基本语法">pip 基本语法</h2>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip &lt;pip arguments&gt;</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>python -m pip</code>：使用你指定为 <code>python</code> 的 Python 解释器去执行 <code>pip</code></li>
</ul>
<blockquote>
<p>提示：也可以直接运行 <code>pip &lt;pip arguments&gt;</code>，但是，还是前面说的那个问题，在运行时要清楚这个 <code>pip</code> 属于谁，当然 <code>python -m pip</code> 也存在同样的问题，运行时也同样要清楚 <code>python</code> 属于哪个版本。</p>
</blockquote>
<h2 id="pip-常用的命令">pip 常用的命令</h2>
<h3 id="pip-自更新">pip 自更新</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip install --upgrade pip</span><br></pre></td></tr></tbody></table></figure>
<h3 id="pip-安装-packages">pip 安装 Packages</h3>
<p>第一种安装方式，也是最常见的情况，使用 Requirement Specifiers<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> 从 <a href="https://pypi.org/">PyPI</a> 安装：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip install SomePackage            <span class="comment"># latest version</span></span><br><span class="line">python -m pip install SomePackage==1.0.4     <span class="comment"># specific version</span></span><br><span class="line">python -m pip install <span class="string">'SomePackage&gt;=1.0.4'</span>     <span class="comment"># minimum version</span></span><br></pre></td></tr></tbody></table></figure>
<p>第二种安装方式，在项目中常用，使用 <code>requirements</code> 文件<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>进行安装：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip install -r requirements.txt</span><br></pre></td></tr></tbody></table></figure>
<p><code>requirements</code> 文件常常配合着 <code>pip freeze</code> 命令进行使用，将 <code>pip freeze</code> 的结果保存到 <code>requirements</code> 文件中：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip freeze &gt; requirements.txt</span><br></pre></td></tr></tbody></table></figure>
<p>第三种安装方式，通过 <code>wheel</code> 进行安装<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip install SomePackage-1.0-py2.py3-none-any.whl</span><br></pre></td></tr></tbody></table></figure>
<p>其实，如果阅读得仔细的话，到这也许就会意识到，前面在对 pip 进行安装时，用到的 <code>ensurepip</code> 包内其实有 <code>pip-23.0.1-py3-none-any.whl</code></p>
<h3 id="pip-卸载-packages">pip 卸载 Packages</h3>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip uninstall SomePackage</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>注意：pip 还会在升级到新版本之前自动卸载旧版本的包</p>
</blockquote>
<h3 id="pip-列出-packages">pip 列出 Packages</h3>
<p>列出已安装的包：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip list</span><br></pre></td></tr></tbody></table></figure>
<p>列出过时的包，并显示可用的最新版本：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip list --outdated</span><br></pre></td></tr></tbody></table></figure>
<p>显示有关已安装包的详细信息：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip show sphinx</span><br></pre></td></tr></tbody></table></figure>
<h3 id="pip-搜索-packages">pip 搜索 Packages</h3>
<p>pip 可以使用 <code>pip search</code> 命令在 PyPI 中搜索包：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip search <span class="string">"query"</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>Notes：PyPI no longer supports 'pip search' (or XML-RPC search). Please use https://pypi.org/search (via a browser) instead.</p>
</blockquote>
<h2 id="pip-其它的命令">pip 其它的命令</h2>
<h3 id="pip-命令补全">pip 命令补全</h3>
<p>pip 支持 bash、zsh 和 fish 中的命令行补全。</p>
<p>为 bash 设置命令行补全：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip completion --bash &gt;&gt; ~/.profile</span><br></pre></td></tr></tbody></table></figure>
<p>为 zsh 设置设置命令行补全：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip completion --zsh &gt;&gt; ~/.zprofile</span><br></pre></td></tr></tbody></table></figure>
<h3 id="pip-freeze">pip freeze</h3>
<p>以需求格式输出已安装的包，包以不区分大小写的排序顺序列出。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip freeze</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">docutils==0.11</span><br><span class="line">Jinja2==2.7.2</span><br><span class="line">MarkupSafe==0.19</span><br><span class="line">Pygments==1.6</span><br><span class="line">Sphinx==1.2.2</span><br></pre></td></tr></tbody></table></figure>
<h2 id="pip-配置">pip 配置</h2>
<p>pip 允许用户通过 3 种机制更改其行为<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a>：</p>
<ul>
<li>command line options 命令行选项（利用 <code>pip config</code> 命令）</li>
<li>environment variables 环境变量</li>
<li>configuration files 配置文件</li>
</ul>
<p>可以对 pip 进行一些个性化的设置，比如：当下载第三库速度太慢时，可以通过设置镜像源加快下载速度。</p>
<p>下面将主要介绍两个比较常用的更改方式：命令行选项和配置文件。</p>
<h3 id="pip-config">pip config</h3>
<p>命令行选项覆盖环境变量，环境变量覆盖配置文件中的值。即：通过命令行选项进行设置的优先级最高。</p>
<p>列出配置文件及其下定义的值：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip config debug</span><br></pre></td></tr></tbody></table></figure>
<p>查询某一个具体的配置：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip config get command.option</span><br></pre></td></tr></tbody></table></figure>
<p>设置/重置某一个具体的配置：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip config [&lt;file-option&gt;] <span class="built_in">set</span>/unset command.option value</span><br></pre></td></tr></tbody></table></figure>
<p>具体实例：</p>
<p>通过命令行选项设置镜像源</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></tbody></table></figure>
<p>通过命令行选项设置 pip 日志</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip config <span class="built_in">set</span> global.log /var/log/pip.log</span><br></pre></td></tr></tbody></table></figure>
<h3 id="pip-配置文件">pip 配置文件</h3>
<p>配置文件可以更改命令行选项的默认值。它们是使用标准 INI 格式的配置文件编写的。</p>
<p>pip 有 3 个 "级别" 的配置文件：</p>
<ul>
<li><code>global</code>：系统范围的配置文件，跨用户共享</li>
<li><code>user</code>：每个用户的配置文件</li>
<li><code>site</code>：每个环境的配置文件，即：每个虚拟环境</li>
</ul>
<p>pip 的配置文件位于相当标准的位置，并且这个位置在不同的操作系统上是不同的，利用 <code>pip config</code> 命令 <code>-debug</code> 选项可以进行查询：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">python -m pip config -debug</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">env_var:</span><br><span class="line"><span class="built_in">env</span>:</span><br><span class="line">global:</span><br><span class="line">  /Library/Application Support/pip/pip.conf, exists: False</span><br><span class="line">site:</span><br><span class="line">  /usr/local/opt/python@3.11/Frameworks/Python.framework/Versions/3.11/pip.conf, exists: False</span><br><span class="line">user:</span><br><span class="line">  /Users/borne/.pip/pip.conf, exists: False</span><br><span class="line">  /Users/borne/.config/pip/pip.conf, exists: False</span><br></pre></td></tr></tbody></table></figure>
<p>此外，环境变量 <code>PIP_CONFIG_FILE</code> 可用于指定首先加载的配置文件，其值将被上述文件中设置的值覆盖。将此值设置为 <code>os.devnull</code> 将禁用所有配置文件的加载。</p>
<p>当存在多个配置文件时，pip 会按照以下顺序组合它们：</p>
<ul>
<li><p><code>PIP_CONFIG_FILE</code>（如果设置了的话）</p></li>
<li><p><code>global</code></p></li>
<li><p><code>user</code></p></li>
<li><p><code>site</code></p></li>
</ul>
<p>注意：每个文件读取都会覆盖从先前文件读取的任何值，即：<code>site</code> 配置文件的优先级是最高的</p>
<p>下面将展示几个配置文件的设置实例：</p>
<p>设置镜像源（<code>index-url</code>）以及请求超时时间（<code>timeout</code>）</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">timeout</span> = <span class="number">60</span></span><br><span class="line"><span class="attr">index-url</span> = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></tbody></table></figure>
<p>或者让 pip 走代理（<code>proxy</code>）</p>
<figure class="highlight ini"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">proxy</span> = http://ip:port</span><br></pre></td></tr></tbody></table></figure>
<p>简单总结一下，关于 pip 配置文件设置的几个关键点：</p>
<ul>
<li>pip 配置文件格式：<code>ini</code></li>
<li>设置的名称源自长命令行选项，比如：<code>--index-url</code></li>
<li>每个子命令都可以在其自己的部分中进行选择性配置，并且将覆盖具有相同名称的全局设置</li>
</ul>
<h2 id="后记">后记</h2>
<p>对于掌握一个工具来说，除了了解这个工具的一些常用命令外，最重要的就是熟悉关于这个工具的配置文件：</p>
<ul>
<li>知道配置文件在哪</li>
<li>如何对配置文件进行一些常规设置</li>
<li>设置日志文件的位置</li>
</ul>
<p>知道配置文件在哪以及进行常规配置保证了工具能够按照自己想要的方式运行，设置日志文件的位置能够在工具运行出错时，知道去哪排查错误。</p>
<h2 id="参考">参考</h2>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn1" role="doc-endnote"><p>pip documentation v23.1.2 : https://pip.pypa.io/en/stable/<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>还有一种比较常见的解释器 <code>IPython</code>，用 <code>In [序号]:</code> 作为提示符。比如：Anaconda 中的 Spyder<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>通过 <code>help(sys)</code> 可以查询 <code>sys</code> 模块的信息，该模块提供对某些对象的访问，比如：解释器使用或者维护的一些模块（<code>sys.path</code>, <code>sys.argv</code> 和 <code>sys.modules</code>等等）以及和解释器进行强交互的一些函数（<code>stdin</code>, <code>stdout</code> 和 <code>stderr</code>等等）<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>Requirement Specifiers - pip documentation v23.1.2：https://pip.pypa.io/en/stable/reference/requirement-specifiers/#requirement-specifiers<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>Requirements File Format - pip documentation v23.1.2：https://pip.pypa.io/en/stable/reference/requirements-file-format/#requirements-file-format<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>事实上，Python 的包安装程序 pip 总是更喜欢 wheel，因为相比于 sdist ，wheel 安装总是更快：https://packaging.python.org/en/latest/overview/<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>Configuration - pip documentation v23.1.2：https://pip.pypa.io/en/stable/topics/configuration/#config-file<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>包管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 下 MIT/GNU Scheme 安装</title>
    <url>/archives/MIT-GNU-Scheme-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="一支持-windows-的mitgnu-scheme-版本">一、支持 Windows 的MIT/GNU Scheme 版本</h2>
<p>首先，访问 <a href="https://www.gnu.org/software/mit-scheme/">MIT/GNU Scheme</a> 的主页，去下载适用于 Windows 的二进制包，但是从官网给出的信息中发现，目前 MIT/GNU Scheme 的最新版本（12.1），已经不再支持 Windows，</p>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/MIT%20GNU%20Scheme%20Release%20status%20and%20future%20plans.png" alt="MIT/GNU Scheme Release status and future plans"><figcaption aria-hidden="true">MIT/GNU Scheme Release status and future plans</figcaption>
</figure>
<p>所以只能去寻找支持 Windows 的<a href="https://ftp.gnu.org/gnu/mit-scheme/stable.pkg/">历史版本</a>，经过一番搜寻发现支持 Windows 的 MIT/GNU Scheme 的最新版本为 <a href="https://ftp.gnu.org/gnu/mit-scheme/stable.pkg/9.2/">9.2 版本</a>，下载相应的 Windows 的二进制包：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/mit-scheme-9.2.png" alt="MIT/GNU Scheme 9.2 版本"><figcaption aria-hidden="true">MIT/GNU Scheme 9.2 版本</figcaption>
</figure>
<p>和安装其它软件一样，安装 MIT/GNU Scheme 没什么特别的，下载好 <a href="https://ftp.gnu.org/gnu/mit-scheme/stable.pkg/9.2/mit-scheme-9.2-i386-win32.exe">mit-scheme-9.2-i386-win32.exe</a> 后，点击安装即可，如果没什么特殊需求直接一直点击 "下一步" 即可完成安装。</p>
<h2 id="二requested-allocation-is-too-large.-try-again-with-a-smaller-argument-to--heap.">二、Requested allocation is too large. Try again with a smaller argument to'--heap'.</h2>
<p>由于 MIT/GNU Scheme 从 9.2 版本之后，就不再提供对于 Windows 的支持，所以下载完成之后直接运行 MIT/GNU Scheme 会出现错误：</p>
<p><img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/MIT/GNU%20Scheme%20terminating.png" alt="MIT/GNU Scheme terminating" style="zoom:50%;"></p>
<p>根据提示，需要利用 <code>--heap</code> 对 MIT/GUN Scheme 进行设置：</p>
<p><img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/MIT%20GNU%20Scheme%20%E5%B1%9E%E6%80%A7.png" alt="MIT/GNU Scheme 属性" style="zoom:50%;"></p>
<p>将 "目标(T)" 修改为 <code>"D:\Program Files (x86)\MIT-GNU Scheme\bin\mit-scheme.exe" --library "D:\Program Files (x86)\MIT-GNU Scheme\lib" --heap 512 --edit</code>，修改完成后，再次运行 MIT/GNU Scheme，发现原来的错误已经消失，能够成功运行程序。</p>
<h2 id="三edwin-环境下-以命令行交互方式启动-scheme">三、Edwin 环境下 / 以命令行交互方式启动 Scheme</h2>
<p>默认情况下，MIT GNU Scheme 会以 Edwin 环境下启动 Scheme。其中，Edwin 是一个类似 emacs 的编辑器。</p>
<h3 id="edwin-环境下的-scheme">Edwin 环境下的 Scheme</h3>
<p>Edwin 与 命令交互状态之间可以相互切换，详见 <a href="https://www.math.pku.edu.cn/teachers/qiuzy/progtech/scheme/mit_scheme.htm">MIT Scheme 的基本使用</a> 文档。</p>
<p>下面简单介绍一下 Edwin 环境下的 Scheme 的一些常用指令：</p>
<ul>
<li><code>C-x z</code>（表示按 Ctrl-x 后按 z 键）：从 Edwin 中退到 Scheme 的命令交互状态。此时 Edwin 挂起，可用 <code>(edit)</code> 唤醒挂起的 Edwin，回到挂起前的状态；</li>
<li><code>C-x c</code>：停止 Edwin 并回到 Scheme 的命令交互状态；</li>
<li><code>C-x C-z</code>：停止 Edwin 并挂起 Scheme 系统。再次启动 Scheme 将唤醒挂起的 Scheme 系统，回到挂起前的系统状态；</li>
<li><code>C-x C-c</code>：停止 Edwin 和 Scheme 系统。</li>
</ul>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Edwin%20scheme.png" alt="Edwin 环境下的 MIT/GNU Scheme"><figcaption aria-hidden="true">Edwin 环境下的 MIT/GNU Scheme</figcaption>
</figure>
<h3 id="命令行交互方式下的-scheme">命令行交互方式下的 Scheme</h3>
<p>接着，简单介绍一下 命令行交互方式下的 Scheme 的一些常用指令：</p>
<ul>
<li>从进入 Edwin：在交互方式下执行 <code>(edit)</code> 或 <code>(edwin)</code>，将启动或返回 Edwin；</li>
<li>在提示符下键入下面表达式并回车：<code>1 ]=&gt; (exit)</code> ，从命令行交互方式下退出。</li>
</ul>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/MIT%20Scheme%20%E4%BA%A4%E4%BA%92%E5%BC%8F.png" alt="命令行交互式下的 MIT/GNU Scheme"><figcaption aria-hidden="true">命令行交互式下的 MIT/GNU Scheme</figcaption>
</figure>
<h3 id="将命令行交互方式设置为-scheme-的默认启动方式">将命令行交互方式设置为 Scheme 的默认启动方式</h3>
<p>由于比较常用 Scheme 的命令行交互方式，所以下面将其设置为默认启动方式，避免每次切换的麻烦。</p>
<p>设置方式非常简单，只需要将前面 "目标(T)" 中 ：</p>
<p><code>"D:\Program Files (x86)\MIT-GNU Scheme\bin\mit-scheme.exe" --library "D:\Program Files (x86)\MIT-GNU Scheme\lib" --heap 512 --edit</code> 的 <code>--edit</code> 去掉即可，</p>
<p>即：将 "目标(T)" 修改为<code>"D:\Program Files (x86)\MIT-GNU Scheme\bin\mit-scheme.exe" --library "D:\Program Files (x86)\MIT-GNU Scheme\lib" --heap 512</code></p>
<p>当然，如果想保留 Edwin 环境下启动 Scheme 的默认方式，也可以将这段指令：</p>
<p><code>"D:\Program Files (x86)\MIT-GNU Scheme\bin\mit-scheme.exe" --library "D:\Program Files (x86)\MIT-GNU Scheme\lib" --heap 512</code></p>
<p>放到 <code>.txt</code> 文本中去，保存之后，修改文件后缀为 <code>.bat</code>，每次想以命令行交互方式启动就点击文件即可。</p>
<h2 id="参考">参考：</h2>
<ul>
<li>安装MIT-Scheme: https://deathking.github.io/yast-cn/contents/chapter1.html</li>
<li>Linux和Windows下安装MIT Scheme - LunaElf - 博客园: https://www.cnblogs.com/lunaelf/p/5275620.html</li>
<li>MIT Scheme 的基本使用: https://www.math.pku.edu.cn/teachers/qiuzy/progtech/scheme/mit_scheme.htm</li>
<li>介绍 | Scheme 语言简明教程: https://wizardforcel.gitbooks.io/teach-yourself-scheme/content/index.html</li>
<li>MIT/GNU Scheme - GNU Project - Free Software Foundation --- MIT/GNU 计划 - GNU 项目 - 自由软件基金会: https://www.gnu.org/software/mit-scheme/</li>
</ul>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Lisp</tag>
        <tag>MIT/GNU Scheme</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用Latex组织文献?</title>
    <url>/archives/%E5%A6%82%E4%BD%95%E7%94%A8Latex%E7%BB%84%E7%BB%87%E6%96%87%E7%8C%AE/</url>
    <content><![CDATA[<p>不管是否使用 <span class="math inline">\(\LaTeX\)</span> 对文章的参考文献进行组织，对于一篇文章的参考文献都由两个最基本的部分组成：</p>
<ul>
<li>参考文献在正文中引用（包括：引用的方式和样式）</li>
</ul>
<figure>
<img data-src="https://raw.githubusercontents.com/Yapwn/BlogDataBase/master/Obsidian202308241301531.png" alt="参考文献在正文中引用"><figcaption aria-hidden="true">参考文献在正文中引用</figcaption>
</figure>
<ul>
<li>文章末尾参考文献列表的生成（包括：生成的方式和样式）</li>
</ul>
<figure>
<img data-src="https://raw.githubusercontents.com/Yapwn/BlogDataBase/master/Obsidian202308241302184.png" alt="文章末尾参考文献列表的生成"><figcaption aria-hidden="true">文章末尾参考文献列表的生成</figcaption>
</figure>
<span id="more"></span>
<p>在下面即将要介绍的三种方法中，不管是哪一种方法，对于参考文献在正文中引用的方式都是相同的：</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\cite</span>{⟨citation⟩}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>⟨citation⟩</code> 为引用的参考文献的标签；</p></li>
<li><p><code>\cite</code> 带一个可选参数，为引用的编号后加上额外的内容，如：<code>\cite[page 22]{Paper2013}</code>，可能得到形如 <code>[13, page 22]</code> 这样的引用；</p></li>
</ul>
<blockquote>
<p>注意：下面对于三种方法的介绍中将不再提及参考文献在正文中的引用方式，重点介绍参考文献列表的生成方式，以及样式的设置。</p>
</blockquote>
<h1 id="第一种最基本的参考文献和引用不推荐">第一种：最基本的参考文献和引用（不推荐）</h1>
<p>简单介绍一下使用 <span class="math inline">\(\LaTeX{}\)</span> 自带的参考文献组织方式生成参考文献列表</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\begin</span>{thebibliography}{⟨widest label⟩}</span><br><span class="line"></span><br><span class="line"><span class="keyword">\bibitem</span>[⟨item number⟩]{⟨citation⟩} ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>{thebibliography}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><p><code>⟨citation⟩</code> 是 <code>\cite</code> 使用的文献标签；</p></li>
<li><p><code>⟨item number⟩</code> 自定义参考文献的序号，如果省略， 则按自然排序给定序号；</p></li>
<li><p><code>⟨widest label⟩</code> 用以限制参考文献序号的宽度，如：99 意味着不超过两位数字。通常设定为与参考文献的数目一致。</p></li>
</ul>
<h1 id="第二种使用-mathrmbscriptstyleibtex-格式组织参考文献">第二种：使用 <span class="math inline">\(\mathrm{B\scriptstyle{IB}}\TeX\)</span> 格式组织参考文献</h1>
<p><span class="math inline">\(\mathrm{B\scriptstyle{IB}}\TeX\)</span> 格式的组织参考文献主要分成两个部分：</p>
<ul>
<li><span class="math inline">\(\mathrm{B\scriptstyle{IB}}\TeX\)</span> 数据库：用来管理参考文献数据
<ul>
<li>数据文件以 <code>.bib</code> 作为扩展名，比如：<code>ref.bib</code>；</li>
<li>通过 <code>\bibliography{}</code> 生成参考文献列表，比如：<code>\bibliography{ref}</code>，不包括扩展名；</li>
</ul></li>
<li><span class="math inline">\(\mathrm{B\scriptstyle{IB}}\TeX\)</span> 样式：决定了参考文献的写法
<ul>
<li>样式文件以 <code>.bst</code> 为扩展名；</li>
<li>通过 <code>\bibliographystyle{}</code> 设置样式，比如：<code>\bibliographystyle{plain}</code>，不包括扩展名；</li>
</ul></li>
</ul>
<p>具体实践：</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>{article}</span><br><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"><span class="keyword">\bibliographystyle</span>{plain} <span class="comment">% 设置 bibtex 样式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>{document}</span><br><span class="line"><span class="comment">% 正文内容</span></span><br><span class="line"><span class="keyword">\section</span>{Some words}</span><br><span class="line">This is a example <span class="keyword">\cite</span>{citation1}.</span><br><span class="line">······</span><br><span class="line"></span><br><span class="line"><span class="comment">% 导入 bibtex 文献数据 ref.bib，按照 \bibliographystyle 设置的样式生成参考文献列表</span></span><br><span class="line"><span class="comment">% 注意：BIBTEX 程序在生成参考文献列表的时候，通常只列出用了 \cite 命令引用的那些。</span></span><br><span class="line"><span class="comment">% \nocite{⟨citation⟩} 命令可以列出未被引用的文献</span></span><br><span class="line"><span class="keyword">\bibliography</span>{ref} </span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>{document}</span><br><span class="line"><span class="comment">% 此后内容会被忽略</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="第三种使用-biblatex-宏包组织参考文献">第三种：使用 biblatex 宏包组织参考文献</h1>
<p>biblatex 宏包组织参考文献的思路于 <span class="math inline">\(\mathrm{B\scriptstyle{IB}}\TeX\)</span> 大致相同，主要区别如下：</p>
<ul>
<li>biblatex 宏包将文献数据的导入和生成参考文献列表分成了两步
<ul>
<li><code>\addbibresource{ref.bib}</code> 导入文献数据；</li>
<li><code>\printbibliography</code> 生成参考文献列表；</li>
</ul></li>
<li>biblatex 宏包在导入时通过 <code>⟨key⟩ = ⟨value⟩</code> 形式进行一些内容的设定，包括
<ul>
<li>参考文献样式 <code>style</code>，在 biblatex 宏包样式又被细分为著录样式和引用样式
<ul>
<li><p>可以统一进行设定：</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[style=gb7714-2015]{biblatex}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>也可以分别进行设定： </p><figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>[bibstyle=gb7714-2015,citestyle=authoryear]{biblatex}</span><br></pre></td></tr></tbody></table></figure><p></p></li>
</ul></li>
<li>参考文献著录排序的规则 <code>sorting</code></li>
</ul></li>
<li>biblatex 宏包在正文中引用参考文献的形式更丰富，除了使用 <code>\cite</code> 之外，还可以使用
<ul>
<li><code>\citeauthor</code> 单独引用作者；</li>
<li><code>\citeyear</code> 单独引用年份；</li>
</ul></li>
<li>编译方式不同，biblatex 宏包使用 biber 程序处理参考文献，而 <span class="math inline">\(\mathrm{B\scriptstyle{IB}}\TeX\)</span> 使用 bibtex 程序
<ul>
<li><span class="math inline">\(\mathrm{B\scriptstyle{IB}}\TeX\)</span> 编译过程：xelatex -&gt; bibtex -&gt; xelatex*2</li>
<li>biblatex 宏包编译过程：xelatex -&gt; biber -&gt; xelatex*2</li>
</ul></li>
</ul>
<p>具体实践：</p>
<figure class="highlight latex"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">\documentclass</span>{article}</span><br><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用符合 GB/T 7714-2015 规范的参考文献样式</span></span><br><span class="line"><span class="keyword">\usepackage</span>[style=gb7714-2015]{biblatex}</span><br><span class="line"><span class="comment">% 导入文献数据文件，包括了文件的扩展名</span></span><br><span class="line"><span class="keyword">\addbibresource</span>{ref.bib}</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>{document}</span><br><span class="line"><span class="comment">% 正文内容</span></span><br><span class="line"><span class="keyword">\section</span>{Some words}</span><br><span class="line">This is a example <span class="keyword">\cite</span>{citation1}.</span><br><span class="line">······</span><br><span class="line"></span><br><span class="line"><span class="comment">% 利用 \addbibresource 导入的数据以及导入 biblatex 宏包时设置的样式，生成参考文献列表</span></span><br><span class="line"><span class="comment">% 注意：biber 程序在生成参考文献列表的时候，通常只列出用了 \cite 命令引用的那些。</span></span><br><span class="line"><span class="comment">% \nocite{⟨citation⟩} 命令可以列出未被引用的文献</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\printbibliography</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\end</span>{document}</span><br><span class="line"><span class="comment">% 此后内容会被忽略</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="参考文献">参考文献</h1>
<div id="refer-anchor">

</div>
<ul>
<li><p>[1] <a href="https://mirrors.tuna.tsinghua.edu.cn/CTAN/biblio/bibtex/base/btxdoc.pdf">所有类别的文献条目格式的参考文档</a></p></li>
<li><p>[2]<a href="https://texdoc.org/serve/lshort-zh-cn.pdf/0">一份不太简短的LATEX2ε 介绍</a></p></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解极大似然估计？</title>
    <url>/archives/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="引入">1 引入</h3>
<p>首先，来看这样一个例子：</p>
<p>一口袋中有许多红球和白球，只知道数目比例为<span class="math inline">\(1:3\)</span>，不知道哪种多，通过实验来判断红球占的比例是<span class="math inline">\(\frac{1}{4}\)</span>还是<span class="math inline">\(\frac{3}{4}\)</span>。</p>
<p>今用有放回抽取的方法从口袋中抽取<span class="math inline">\(n\)</span>个球，将红球的个数记为<span class="math inline">\(X\)</span>，则<span class="math inline">\(X\)</span>服从二项分布<span class="math inline">\(B(n,p)\)</span>。如何由实验结果来估计<span class="math inline">\(p\)</span>的值？</p>
<p>现在假设有这样一个实验结果：从口袋中抽取了100个球，其中红球的个数为80个，那么相应的抽取到白球的个数就为20个。</p>
<p>如果现在要求你从上述的实验结果中去判断红球占的比例是<span class="math inline">\(\frac{1}{4}\)</span>还是<span class="math inline">\(\frac{3}{4}\)</span>，大概很多人会选择<span class="math inline">\(\frac{3}{4}\)</span>，这是一个很自然的选择，因为抽取的100个球中，红球占了大多数。（当然最后的结果有没有可能是红球占的比例是<span class="math inline">\(\frac{1}{4}\)</span>，也有可能，但是在当前实验结果下，我们会认为出现这样结果的可能性会很小）</p>
<p>其实，在进行上述选择（根据实验结果去判断红球所占比例）过程中，我们不自觉的运用到了<strong>极大似然估计的思想</strong>，即：<strong>根据已经发生的结果，去选择一个原因，使得出现这样结果的可能性最大</strong>。换句话说，结果是在使它出现可能性最大的那个原因下发生的。</p>
<p>具体到这个例子，<strong>结果</strong>是从口袋中抽取了100个球，其中有80个都是红球；那么导致最大可能性出现该结果的<strong>原因</strong>就是原来口袋中红球所占的比例是<span class="math inline">\(\frac{3}{4}\)</span>。</p>
<span id="more"></span>
<h3 id="分析">2 分析</h3>
<p>根据极大似然估计的思想，可以在这简单总结一下，如何在一个具体实例中去运用：</p>
<ol type="1">
<li>求出发生该结果的一个概率表达式（其中可能带有未知参数，通俗理解就是<strong>原因</strong>）；</li>
<li>根据概率表达式，调整未知参数（选择<strong>原因</strong>），使得出现该结果的概率最大。</li>
</ol>
<p>下面，根据上述两个步骤，来看一下这样一个例子：</p>
<p>设总体<span class="math inline">\(X \sim\left(\begin{array}{ccc}1 &amp; 2 &amp; 3 \\ 1-\theta^2 &amp; \frac{\theta^2}{2} &amp; \frac{\theta^2}{2}\end{array}\right), \theta(0&lt;\theta&lt;1)\)</span>未知，现得一样本值<span class="math inline">\(1,3,2,3\)</span>，求<span class="math inline">\(\theta\)</span>的极大似然估计值。</p>
<p>第一步，求出出现<span class="math inline">\(1,3,2,3\)</span>结果的概率表达式： <span class="math display">\[
\begin{aligned}
&amp; P\left\{\left(X_1, X_2, X_3, X_4\right)=(1,3,2,3)\right\} \\
&amp; =P\left\{X_1=1, X_2=3, X_3=2, X_4=3\right\} \\
&amp; =P\left\{X_1=1\right\} P\left\{X_2=3\right\} P\left\{X_3=2\right\} P\left\{X_4=3\right\} \\
&amp; =P\{X=1\} P\{X=3\} P\{X=2\} P\{X=3\} \\
&amp; =\frac{1}{8} \theta^6\left(1-\theta^2\right) \triangleq L(\theta)
\end{aligned}
\]</span> 第二步，根据概率表达式，调整未知参数，使得出现该结果的概率最大： <span class="math display">\[
\begin{aligned}
&amp; L(\theta)=\frac{1}{8} \theta^6\left(1-\theta^2\right), \quad 0&lt;\theta&lt;1 \\
&amp; \ln L(\theta)=\ln \frac{1}{8}+6 \ln \theta+\ln \left(1-\theta^2\right) \\
&amp; \text { 令 } \frac{d}{d \theta} \ln L(\theta)=\frac{6}{\theta}-\frac{2 \theta}{1-\theta^2}=0
\end{aligned}
\]</span> 解出<span class="math inline">\(\theta\)</span>的极大似然估计值<span class="math inline">\(\hat{\theta}=\frac{\sqrt{3}}{2}\)</span>。</p>
<p>从上面这个例子中，可以发现使用极大似然估计的一个必要条件是需要知道<strong>总体类型（分布）</strong>，因为只有这样才能求出结果的概率表达式。</p>
<h3 id="总结">3 总结</h3>
<p>最后，大致来总结一下极大似然估计（Maximum Likelihood Estimation，MLE）方法：</p>
<ol type="1">
<li><p>离散型</p>
<p>设总体<span class="math inline">\(X\)</span>的分布律：<span class="math inline">\(P\left\{X=x\right\}=p\left(x;\theta\right)\)</span>，<span class="math inline">\(\theta\in \Theta\)</span>，<span class="math inline">\(\theta\)</span>未知，<span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>是总体<span class="math inline">\(X\)</span>的一个样本，<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>为样本值。称<span class="math inline">\(L(\theta)=\prod \limits^{n}_{i=1}p(x_{i};\theta)\)</span>为样本的似然函数，<span class="math inline">\(L(\theta)\)</span>的意义为样本值（结果）出现的概率。</p>
<p>令<span class="math inline">\(\frac{d}{d\theta}lnL(\theta)=0,\theta \in \Theta\)</span>，则：</p>
<p><span class="math inline">\(\hat{\theta}\left(x_1,x_2,\cdots,x_n\right)\)</span>为<span class="math inline">\(\theta\)</span>的极大似然估计<strong>值</strong>；<span class="math inline">\(\hat{\theta}\left(X_1,X_2,\cdots,X_n\right)\)</span>为<span class="math inline">\(\theta\)</span>的极大似然估计<strong>量</strong>。</p></li>
<li><p>连续型</p>
<p>设总体<span class="math inline">\(X\)</span>的概率密度函数：<span class="math inline">\(f\left(x;\theta\right),\theta \in \Theta\)</span>，<span class="math inline">\(\theta\)</span>未知，<span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>是总体<span class="math inline">\(X\)</span>的一个样本，<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>为样本值。</p>
<blockquote>
<p>注意：<span class="math inline">\(\left(X_1,X_2,\cdots,X_n\right)\)</span>在<span class="math inline">\(\left(x_1,x_2,\cdots,x_n\right)\)</span>附近取值的概率正比于<span class="math inline">\(\left(X_1,X_2,\cdots,X_n\right)\)</span>的联合密度在<span class="math inline">\(\left(x_1,x_2,\cdots,x_n\right)\)</span>处的函数值。（因为在连续型分布中取到某点的概率为零，故改为在以该点为中心的一个微小邻域上进行取值）</p>
</blockquote>
<p>记<span class="math inline">\(L\left(\theta\right)=\prod \limits^{n}_{i=1}f\left(x_i;\theta\right)\)</span>称为样本的似然函数。<span class="math inline">\(L(\theta)\)</span>的意义为正比于样本值出现的概率。</p>
<p>令<span class="math inline">\(\frac{d}{d\theta}lnL(\theta)=0,\theta \in \Theta\)</span>，则：</p>
<p><span class="math inline">\(\hat{\theta}\left(x_1,x_2,\cdots,x_n\right)\)</span>为<span class="math inline">\(\theta\)</span>的极大似然估计<strong>值</strong>；<span class="math inline">\(\hat{\theta}\left(X_1,X_2,\cdots,X_n\right)\)</span>为<span class="math inline">\(\theta\)</span>的极大似然估计<strong>量</strong>。</p></li>
</ol>
<h3 id="补充">4 补充</h3>
<p>对于离散型总体和连续型总体分别进行实例的补充：</p>
<ol type="1">
<li><p>离散型</p>
<p>设总体<span class="math inline">\(X\)</span>服从几何分布，<span class="math inline">\(p(0&lt;p&lt;1)\)</span>未知， <span class="math display">\[
P\left\{X=k\right\}=\left(1-p\right)^{k-1}p, \quad k=1,2,\cdots
\]</span> 求<span class="math inline">\(p\)</span>的极大似然估计。</p>
<p>解：设<span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>是总体<span class="math inline">\(X\)</span>的一个样本，<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>为样本值。</p>
<p>概率密度函数：<span class="math inline">\(p\left(x;p\right)=\left(1-p\right)^{x-1}p,\quad x=1,2,\cdots\)</span></p>
<p>似然函数： <span class="math display">\[
\begin{aligned}
L(p) &amp; =\prod\limits^{n}_{i=1} p\left(x_i ; p\right)=\prod\limits^{n}_{i=1}(1-p)^{x_i-1} p =p^n(1-p)^{n \bar{x}-n} \\
\end{aligned}
\]</span> <span class="math display">\[
lnL(p) =n \ln p+(n \bar{x}-n) \ln (1-p)
\]</span></p>
<p><span class="math inline">\(\text { 令 } \frac{d}{d p} \ln L(p)=\frac{n}{p}-\frac{n \bar{x}-n}{1-p}=0\)</span>，有：</p>
<p><span class="math inline">\(\hat{p}=\frac{1}{\bar{x}},\quad p\text{的极大似然估计值}\)</span>；</p>
<p><span class="math inline">\(\hat{p}=\frac{1}{\bar{X}},\quad p\text{的极大似然估计量}\)</span>.</p></li>
<li><p>连续型</p>
<p>设总体<span class="math inline">\(X\)</span>密度<span class="math inline">\(f(x)= \begin{cases}(\theta+1) x^\theta, &amp; 0&lt;x&lt;1 \\ 0, &amp; \text { 其他 }\end{cases}\)</span>，<span class="math inline">\(\theta&gt; -1\)</span>未知，求<span class="math inline">\(\theta\)</span>的极大似然估计。</p>
<p>解：设<span class="math inline">\(X_1,X_2,\cdots,X_n\)</span>是总体<span class="math inline">\(X\)</span>的一个样本，<span class="math inline">\(x_1,x_2,\cdots,x_n\)</span>为样本值。 <span class="math display">\[
\begin{aligned}
&amp; L(\theta)= \begin{cases}\prod_{i=1}^n(\theta+1) x_i^\theta=(\theta+1)^n\left(x_1 x_2 \cdots x_n\right)^\theta, &amp; 0&lt;x_i&lt;1, i=1,2, \cdots, n .\\
\\ 0 ,&amp; \text{其他}\end{cases} \\
\end{aligned}
\]</span></p></li>
</ol>
<p>​ 当<span class="math inline">\(0&lt;x_i&lt;1, i=1,2, \cdots, n \text { 时, }\)</span> <span class="math display">\[
\ln L(\theta)=n \ln (\theta+1)+\theta \sum_{i=1}^n \ln x_i
\]</span> ​ <span class="math inline">\(\text{令}\frac{d}{d \theta} \ln L(\theta)=\frac{n}{\theta+1}+\sum_{i=1}^n \ln x_i=0\text{，有：}\)</span></p>
<p>​ <span class="math inline">\(\hat{\theta}=-\frac{n}{\sum_{i=1}^n \ln x_i}-1，\theta\text{的极大似然估计值；}\)</span></p>
<p>​ <span class="math inline">\(\hat{\theta}=-\frac{n}{\sum_{i=1}^n \ln X_i}-1，\theta \text{的极大似然估计量.}\)</span></p>
]]></content>
      <categories>
        <category>概率论与数理统计</category>
      </categories>
      <tags>
        <tag>参数估计</tag>
        <tag>点估计</tag>
      </tags>
  </entry>
  <entry>
    <title>5min,LOL全球总决赛赛制速览！</title>
    <url>/archives/5min-LOL%E5%85%A8%E7%90%83%E6%80%BB%E5%86%B3%E8%B5%9B%E8%B5%9B%E5%88%B6%E9%80%9F%E8%A7%88%EF%BC%81/</url>
    <content><![CDATA[<p><img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidian1663320404456.jpg" alt="英雄联盟S12全球总决赛" style="zoom: 200%;"></p>
<p>以现在正在如火如荼地进行的英雄联盟S12全球总决赛为例，来总的介绍一下LOL全球总决赛的赛制。</p>
<h2 id="赛程总览">1 赛程总览</h2>
<p>LOL全球总决赛总的分为5个阶段进行，分别如下：</p>
<ul>
<li>入围赛阶段
<ul>
<li>小组赛（9月29日-10月4日）</li>
<li>淘汰赛（10月5日-10月6日）</li>
</ul></li>
<li>小组赛阶段（10月7日-10月16日）</li>
<li>四分之一决赛（10月20日-10月23日）</li>
<li>半决赛（10月29日-10月30日）</li>
<li>决赛（11月5日）</li>
</ul>
<p>下面，分别从这五个阶段来详细介绍一下LOL全球总决赛的赛制。</p>
<span id="more"></span>
<h2 id="入围赛阶段">2 入围赛阶段</h2>
<h3 id="入围赛资格">2.1 入围赛资格</h3>
<p>首先，在详细介绍入围赛赛制之前，有必要先了解一下如何取得入围赛的资格。</p>
<p>每个队伍想要取得入围赛资格都需要参加各自队伍所在地区的LOL顶级职业联赛。其实，也可以通俗的理解为LOL全球总决赛的选拔赛。</p>
<p>目前，LOL全球总决赛参赛队伍的选拔主要分为11大赛区，具体情况如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/ObsidianLOLS12%E5%8F%82%E8%B5%9B%E9%98%9F%E4%BC%8D.png" alt="英雄联盟S12全球总决赛参赛队伍" style="zoom:50%;"></p>
<p>根据上图展示的晋级规则，来自11个赛区的24支队伍中，有12支队伍需要先进行入围赛，共同角逐晋级小组赛的资格，它们分别是：</p>
<ul>
<li>中国赛区(LPL)：RNG</li>
<li>韩国赛区(LCK)：DRX</li>
<li>欧洲赛区(LEC)：FNC、MAD</li>
<li>北美赛区(LCS)：EG</li>
<li>东南亚赛区(PCS)：BYG</li>
<li>越南赛区(VCS)：SGB</li>
<li>巴西赛区(CBLOL)：LLL</li>
<li>日本赛区(LJL)：DFM</li>
<li>拉丁美洲赛区(LLA):ISG</li>
<li>大洋洲赛区(LCO)：CHF</li>
<li>土耳其赛区(TCL)：IW</li>
</ul>
<p>其余的12支队伍可以直接晋级到LOL全球总决赛的小组赛阶段。</p>
<p><img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidian2022%E5%B9%B4%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E5%85%A8%E7%90%83%E6%80%BB%E5%86%B3%E8%B5%9B%E5%8F%82%E8%B5%9B%E9%98%9F%E4%BC%8D%E5%90%8D%E5%8D%95.jpeg" alt="S12参赛队伍" style="zoom:80%;"></p>
<h3 id="入围赛小组赛">2.2 入围赛小组赛</h3>
<h4 id="分组的确定">2.2.1 分组的确定</h4>
<p>入围赛小组赛的分组由抽签决定（今年的抽签仪式于9月12日举行），12支队伍被分成了A、B两组，每组分别由6支队伍组成，分组情况如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidian%E5%85%A5%E5%9B%B4%E8%B5%9B%E5%B0%8F%E7%BB%84%E8%B5%9B%E5%88%86%E7%BB%84.jpeg" alt="S12入围赛小组赛分组" style="zoom:100%;"></p>
<h4 id="比赛赛制">2.2.2 比赛赛制</h4>
<p>入围赛小组赛阶段，各小组之间进行单循环制单场胜负赛（Best Of 1, BO1），每场比赛的选边将随机预先决定，但总的来说妹纸对于将分别在地图的一方（及蓝色或红色）进行三场比赛，剩余两场比赛在地图的另一方进行。</p>
<p>当各组的单循环BO1都进行完毕时，两个小组各自<strong>累计积分第一名的队伍</strong>将自动晋级下一阶段的小组赛，剩余队伍将进行<strong>淘汰赛</strong>。</p>
<p>注意：当出现平局的情况，将会根据平局的队伍数量（比如：两队平局，三队平局以及四队平局等等），依据相互对战的记录以及累计获胜时间来综合决定平局队伍的排序（具体详细规则可以见参考资料<a href="#refer-anchor-1"><sup>[1]</sup></a>）。</p>
<h3 id="入围赛淘汰赛">2.3 入围赛淘汰赛</h3>
<p>入围赛淘汰赛将在两组的第二、三和四名之间进行，第五名和第六名直接淘汰。</p>
<p>各组<strong>排名的第三和第四名的队伍</strong>将进行一场5局3胜的比赛。</p>
<p>获胜的队伍将和另一个入围赛小组<strong>排名第二的队伍</strong>再进行一场5局3胜的比赛。</p>
<p>两场比赛中胜出的队伍将晋级小组赛，并随机分配到小组赛阶段的分组当中去。</p>
<p>以这次S12的入围赛小组赛为例，各组的单循环BO1都进行完毕后，积分榜如下图所示：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidian%E5%85%A5%E5%9B%B4%E8%B5%9B%E5%B0%8F%E7%BB%84%E8%B5%9B%E7%A7%AF%E5%88%86%E6%A6%9C.png" alt="入围赛小组赛积分榜"><figcaption aria-hidden="true">入围赛小组赛积分榜</figcaption>
</figure>
<p>根据前面介绍的入围赛小组赛赛制可知：</p>
<p>首先，A组的第一名（FNC）和B组的第一名（DRX）会直接晋级小组赛</p>
<p>接着，由A组的第三名（LLL）和第四名（DFM）先进行5局3胜赛。（B组也是类似的）</p>
<p>最后，胜出者将会与B组的第二名（RNG）再进行5局3胜赛，最后的胜利者将会晋级小组赛。（B组同理）</p>
<p>下面展示的是这次的比赛结果：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidian%E5%85%A5%E5%9B%B4%E8%B5%9B%E6%B7%98%E6%B1%B0%E8%B5%9B%E6%AF%94%E8%B5%9B%E7%BB%93%E6%9E%9C.png" alt="入围赛淘汰赛比赛结果"><figcaption aria-hidden="true">入围赛淘汰赛比赛结果</figcaption>
</figure>
<h2 id="小组赛阶段">3 小组赛阶段</h2>
<h3 id="分组的确定-1">3.1 分组的确定</h3>
<p>小组赛的分组和入围赛一样，同样由抽签仪式决定（今年的抽签仪式于9月12日举行），今年的分组情况如下：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidian%E5%B0%8F%E7%BB%84%E8%B5%9B%E5%88%86%E7%BB%84%E6%83%85%E5%86%B51.png" alt="S12小组赛分组1"><figcaption aria-hidden="true">S12小组赛分组1</figcaption>
</figure>
<p>前面提到过，由入围赛晋级到小组赛的队伍会被随机分配到小组赛的分组当中，所以最终的分组情况如下：</p>
<p><img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidian%E5%B0%8F%E7%BB%84%E8%B5%9B%E5%88%86%E7%BB%84%E6%83%85%E5%86%B52.jpg" alt="S12小组赛分组2" style="zoom: 28.5%;"></p>
<p>FNC被分到了A组，EG被分到了B组，DRX被分到了C组，RNG被分到了D组。</p>
<h3 id="比赛赛制-1">3.2 比赛赛制</h3>
<p>小组赛阶段各分组队伍之间进行双循环制单场胜负赛（BO1），即：每个小组内每个队伍之间会进行两次比赛。</p>
<p>小组赛选边的话还是随机预先决定，每支队伍将分别在地图的两方与小组内的所有其他队伍进行比赛。</p>
<p>在小组赛阶段之后，根据每个组的积分情况，每个小组的前两名队伍将直接晋级四分之一决赛。</p>
<p>同样，以今年的比赛为例：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidian%E5%B0%8F%E7%BB%84%E8%B5%9B%E6%AF%94%E8%B5%9B%E7%BB%93%E6%9E%9C.png" alt="S12小组赛比赛结果"><figcaption aria-hidden="true">S12小组赛比赛结果</figcaption>
</figure>
<p>A组的T1和EDG，B组的JDG和DK，C组的DRX和RGE以及D组的GEN和RNG直接晋级四分之一决赛。</p>
<p>注意：以A组为例，第一名T1将会作为1号种子，第二名EDG将会作为2号种子。（其他组同理）</p>
<h2 id="四分之一决赛">4 四分之一决赛</h2>
<h3 id="分组的确定-2">4.1 分组的确定</h3>
<p>四分之一决赛中，小组赛阶段获得1号种子的队伍将会迎战另一个分组的2号种子（比如：A组的1号种子T1 VS D组的二号种子RNG），具体对阵将会由小组赛结束之后的抽签来随机决定。</p>
<p>但是，抽签过程需要遵循一下两个原则：</p>
<ul>
<li>排除同一小组的两只队伍（比如：A组的T1和EDG）在总决赛前再次相遇的可能</li>
<li>确保第一场比赛的胜者将在半决赛与第二场比赛的胜者进行对决，而第三场比赛的胜者将与将在半决赛与第四场比赛的胜者进行对对决（即：四分之一决赛被分成了两个区进行，通常称为上半区和下半区）</li>
</ul>
<p>今年四分之一决赛的分组结果如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/ObsidianS%E5%9B%9B%E5%88%86%E4%B9%8B%E4%B8%80%E5%86%B3%E8%B5%9B.jpg" alt="S12四分之一决赛分组" style="zoom: 50%;"></p>
<p>JDG、RGE、T1以及RNG被分配到了上半区，GEN、DK、DRX以及EDG被分配到了下半区。</p>
<h3 id="比赛赛制-2">4.2 比赛赛制</h3>
<p>四分之一决赛将会以5局3胜的赛制来进行。来自同一半区的四分之一决赛的胜者将会在半决赛中相遇。</p>
<p>四分之一决赛选边的话，第一场比赛的选边权属于小组赛阶段各组的一号种子队伍，第一局比赛后的所有比赛中，前一局比赛的负方将会进行选边。</p>
<p>今年四分之一决赛的比赛结果如下图所示：</p>
<p><img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/ObsidianS12%E5%9B%9B%E5%88%86%E4%B9%8B%E4%B8%80%E6%AF%94%E8%B5%9B%E7%BB%93%E6%9E%9C.jpg" alt="S12四分之一比赛结果" style="zoom:50%;"></p>
<h2 id="半决赛">5 半决赛</h2>
<p>半决赛将由在四分之一决赛的胜者之间进行的两场5局3胜制的比赛组成。半决赛的胜者将会在决赛中相遇。</p>
<p>半决赛选边的话，每场半决赛第一局比赛的选边权将会在最后一场四分之一决赛后立即通过掷硬币决定。第一局比赛后的所有比赛中，前一局比赛的负方将会进行选边。</p>
<p>以今年的半决赛为例，JDG和T1以及GEN和DRX之间将会分别进行5局3胜制的比赛，最后的胜者将会进入总决赛，进行最后冠军的角逐。</p>
<h2 id="决赛">6 决赛</h2>
<p>决赛将会由半决赛的获胜者进行一场5局3胜制比赛。决赛的胜者将会成为全球总决赛的冠军。</p>
<p>决赛选边与半决赛选边类似，总决赛的第一场比赛的选边将会在最后一场半决赛后立刻通过掷硬币决定。第一局比赛后的所有比赛中，前一局比赛的负方将会进行选边。</p>
<h2 id="写在最后">写在最后</h2>
<p>现在的写作时间是10月30日的凌晨1点20分，还有几个小时，将会迎来JDG和T1半决赛的比赛，作为LPL今年最后的种子，希望JDG能够顶住压力，赢下T1，晋级总决赛，拿下今年S12的总冠军！</p>
<h2 id="参考资料">参考资料</h2>
<div id="refer-anchor-1">

</div>
<ul>
<li>[1] <a href="https://lol.qq.com/news/detail.shtml?type=1&amp;docid=13933530915132775031">2022全球总决赛规则-英雄联盟官方网站-腾讯游戏</a></li>
</ul>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>E-Sports</tag>
      </tags>
  </entry>
  <entry>
    <title>2min, LPL赛制速览!</title>
    <url>/archives/LPL%E8%B5%9B%E5%88%B6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="lpl-简介">LPL 简介</h2>
<p>在介绍LPL赛制之前，先来简单介绍一下LPL。</p>
<p>英雄联盟职业联赛（League of Legends Pro League），简称LPL，是LOL<strong>中国大陆地区</strong>的顶级职业联赛。</p>
<p>通过LPL，<strong>中国大陆地区</strong>的参赛战队可以获得<strong>LOL全球总决赛</strong>（League of Legends World Championship Series）的入场券。</p>
<p>截止到2022年，LPL有<strong>17支</strong>参赛队伍，最后通过LPL有<strong>4支</strong>参赛队伍可以进入最终的<strong>LOL全球总决赛</strong>。</p>
<span id="more"></span>
<h2 id="lpl-赛制">LPL 赛制</h2>
<p>LPL每年一共进行<strong>两个赛季</strong>的比赛，分别是<strong>春季赛</strong>和<strong>夏季赛</strong>。每季比赛又各分为<strong>常规赛</strong>和<strong>季后赛</strong>两部分。</p>
<p>通过<strong>春季赛</strong>，<strong>夏季赛</strong>的成绩以及<strong>资格赛</strong>（夏季赛之后举行）共同决定最后去参加<strong>LOL全球总决赛</strong>的<strong>4支</strong>参赛队伍。</p>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/ObsidianLPL.png" alt="LPL"><figcaption aria-hidden="true">LPL</figcaption>
</figure>
<h3 id="常规赛">常规赛</h3>
<h4 id="赛制">赛制</h4>
<p>这个阶段一共由17支队伍组成，17支队伍不分组进行组内单循环（BO3，3局2胜）。</p>
<p>每个队伍在每个赛季将进行16场比赛，以联盟形式与其所在地区的对手进行比赛。</p>
<p>每个队伍在每个赛季将与每个对手进行一次比赛，胜一场积一分，比赛排名由积分决定。</p>
<h4 id="决胜原则">决胜原则</h4>
<p>如果每个队的积分都不同，那么直接根据积分进行排名即可。</p>
<p>如果多个队伍积分相同，则比较<strong>总净胜场</strong>数（常规赛中所有<strong>小场胜场-小场败场</strong>），<strong>总净胜场</strong>更多的队伍排名更高。</p>
<p>以今年的夏季常规赛为例，比赛结果如下图所示：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidian" alt="LPL夏季常规赛"><figcaption aria-hidden="true">LPL夏季常规赛</figcaption>
</figure>
<p>TES和JDG两支队伍在16场比赛中，14胜2负均积14分打成平手，这时就会比较净胜分（即：总净胜场数），TES的净胜分（20分）大于JDG（18分），故TES的排名高于JDG的排名。</p>
<h3 id="季后赛">季后赛</h3>
<h4 id="资格">资格</h4>
<p>常规赛中积分最高的前十名将会获得季后赛资格。</p>
<p>以今年的夏季常规赛为例，进入季后赛的10支队伍分别是：TES、JDG、V5、RNG、EDG、WBG、LNG、OM、FPX和BLG。</p>
<h4 id="赛制-1">赛制</h4>
<p>季后赛比赛形式为BO5（5局3胜），被分为两阶段，前一个阶段为分组冒泡赛，后一个阶段为双败淘汰赛。</p>
<h5 id="分组冒泡赛">分组冒泡赛</h5>
<p>第一组：第四、五、八和九名</p>
<p>第二组：第三、六、七和十名</p>
<p>以今年的夏季季后赛为例：</p>
<p>第一组：RNG、EDG、OMG和FPX</p>
<p>第二组：V5、WBG、LNG和BLG</p>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidianimage-20220830205813742.png" alt="image-20220830205813742"><figcaption aria-hidden="true">image-20220830205813742</figcaption>
</figure>
<h5 id="双败淘汰赛">双败淘汰赛</h5>
<p>在分组冒泡赛结束之后，分组冒泡赛的两个组别最后一轮的胜者会与常规赛第一和第二名进行双败淘汰赛。</p>
<p>具体来说，第一组的胜者将会与第一名进行比赛，第二组的胜者将会与第二名进行比赛。</p>
<p>双败淘汰赛的最终胜者，会成为LPL夏季赛的冠军，也是LPL在<strong>LOL全球总决赛</strong>的<strong>一号种子队伍</strong>。</p>
<p>双败赛结束之后，除了一号种子队伍之外，该年度<strong>全球总决赛积分</strong>（春季赛积分+夏季赛积分）累积最高的队伍将成为<strong>二号种子队伍</strong>。</p>
<p>以今年的夏季季后赛为例：</p>
<p>EDG和TES，LNG和JDG会进行双败淘汰赛。</p>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidianimage-20220830210427042.png" alt="image-20220830210427042"><figcaption aria-hidden="true">image-20220830210427042</figcaption>
</figure>
<p>以目前双败淘汰赛的比赛结果来看，<strong>JDG</strong>和<strong>TES</strong>两支队伍将争夺<strong>LPL夏季赛</strong>的冠军，也是<strong>LOL全球总决赛</strong>的第一张入场券。</p>
<h3 id="资格赛">资格赛</h3>
<p>资格赛将在夏季总决赛结束后进行，将会确定代表中国大陆地区参与<strong>LOL全球总决赛</strong>的<strong>三号种子</strong>和<strong>四号种子</strong>队伍。</p>
<p>除了<strong>一号种子</strong>队伍和<strong>二号种子</strong>队伍以外，其他队伍中<strong>全球总决赛积分排名</strong>前4的队伍将进入资格赛（积分相同，则比较夏季赛积分）。</p>
<p>这四支队伍中<strong>全球总决赛积分最高</strong>的两支队伍将进行<strong>比赛一</strong>（BO5），剩余两支队伍进行<strong>比赛二</strong>（BO5）。</p>
<p><strong>比赛一</strong>的<strong>胜者</strong>将会成为<strong>LPL赛区在全球总决赛</strong>的<strong>三号种子队伍</strong>，<strong>比赛二</strong>的<strong>败者</strong>将会被<strong>淘汰</strong>。</p>
<p><strong>比赛一</strong>的<strong>败者</strong>将与<strong>比赛二</strong>的<strong>胜者</strong>进行<strong>比赛三</strong>（BO5），<strong>比赛三</strong>的<strong>胜者</strong>将会成为<strong>LPL赛区在全球总决赛</strong>的<strong>四号种子队伍</strong>，败者将被淘汰。</p>
<h2 id="写在最后">写在最后</h2>
<p>最近，在看LPL，比赛挺精彩的，但是总感觉差点什么，因为在看比赛时总是看到弹幕说：”赢了这场比赛怎样怎样，输了这场比赛又怎样怎样......“，自己对此却毫无感觉，想想是自己根本不了解LPL赛制的缘故（不免有看热闹之嫌），每次看比赛时总想着下来找时间把LPL赛制了解一下，但总是一拖再拖，终于在LPL总决赛前夕，鼓起勇气去了解LPL赛制，顺便做了上面这样一个分享，给同样不太清楚LPL赛制的朋友们。</p>
<h2 id="参考文献">参考文献</h2>
<p>[1] <a href="https://lol.qq.com/news/detail.shtml?type=1&amp;docid=16161886509984835765">英雄联盟职业联赛比赛规则（2022年7月24日规则补充版本）-英雄联盟官方网站-腾讯游戏</a></p>
<p>[2] <a href="https://zh.m.wikipedia.org/zh-hans/%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E8%81%8C%E4%B8%9A%E8%81%94%E8%B5%9B">英雄联盟职业联赛 - 维基百科</a></p>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>E-Sports</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac如何让软件走代理？</title>
    <url>/archives/Mac%E5%A6%82%E4%BD%95%E8%AE%A9%E8%BD%AF%E4%BB%B6%E8%B5%B0%E4%BB%A3%E7%90%86%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="背景">背景</h2>
<p>在使用Mac的过程中，不可避免地会用到一些国外开发的软件，而给这些软件提供服务的服务器大多都不在国内，这就会导致在使用这些软件的时候速度会非常的慢（尤其是遇到软件需要更新的时候）。</p>
<p>一些小伙伴这时候会选择使用代理，希望能够提升软件的速度，但是又会发现所使用的软件并没有走代理，那么如何让相应的软件走代理呢？</p>
<p>这个问题同样困惑了我很久，但最近在查阅文献的时候解决了这个问题，写这篇文章的目的就是为了记录一下解决方案</p>
<span id="more"></span>
<h2 id="大致思路">大致思路</h2>
<p>利用mac的终端（Terminal），先通过让mac的终端走代理，然后再从mac终端中打开相应的软件，实现软件走代理。</p>
<h2 id="实现细节">实现细节</h2>
<h3 id="终端走代理">终端走代理</h3>
<p>通过<code>export</code>命令设置环境变量（仅限于该次登陆操作）</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:端口号 http_proxy=http://127.0.0.1:端口号 all_proxy=socks5://127.0.0.1:端口号</span><br></pre></td></tr></tbody></table></figure>
<p><strong>端口号</strong>取决于代理的配置，查看代理中配置的端口号并填在上面命令的相应位置即可。</p>
<p>通过<code>curl</code>命令，请求google服务器的服务，用来检测终端走代理是否成功</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">curl www.google.com</span><br></pre></td></tr></tbody></table></figure>
<p>上面的命令向<code>www.google.com</code>发出了GET请求，如果返回了网站源码，说明终端走代理成功。</p>
<figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span> <span class="attr">itemscope</span>=<span class="string">""</span> <span class="attr">itemtype</span>=<span class="string">"http://schema.org/WebPage"</span> <span class="attr">lang</span>=<span class="string">"zh-TW"</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span>&gt;</span><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"/images/branding/googleg/1x/googleg_standard_color_128dp.png"</span></span></span><br><span class="line"><span class="tag"><span class="attr">......</span></span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="软件走代理">软件走代理</h3>
<h4 id="mac软件的文件标准">Mac软件的文件标准</h4>
<p>如何在终端中启动一个软件？需要了解在mac中软件的文件标准，即：在mac中一个软件大致包含了哪些文件？</p>
<p>以mac中的微信为例，可以看到mac中软件包含的文件大致情况：</p>
<p><img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidianimage-20220826104500772.png" alt="image-20220826104500772" style="zoom:50%;"></p>
<p>其中，mac中的软件的启动器launch所在的路径通常为：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/Applications/WeChat.app/Contents/MacOS/WeChat</span><br></pre></td></tr></tbody></table></figure>
<p>路径中的<code>Wechat.app</code>可以换成其他想要走代理软件。</p>
<h4 id="终端中打开软件">终端中打开软件</h4>
<p>学会了找一个软件的启动器，那么在终端中打开软件就变的简单，只需要在终端中运行相应的软件启动器即可：</p>
<p>还是以微信为例，只需要在终端中运行：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">/Applications/WeChat.app/Contents/MacOS/WeChat</span><br></pre></td></tr></tbody></table></figure>
<p>就可以在终端中启动微信。（注意：软件启动好后，在软件运行过程中不能关闭终端，否则软件也会相应地关闭）</p>
<p>由于之前已经成功实现让终端走代理，相应地利用终端打开的软件也会自动的走代理，最终实现了目的。</p>
<h2 id="后记">后记</h2>
<p>在mac中实现让软件走代理的方式不止这篇文章中介绍的这中方法，在此之前也尝试过其他许多方法，比如：利用Proxifier软件实现软件的代理，或者配置好代理的规则等等，但是这篇文章中介绍的方法是目前所见的最简单、快捷的实现软件走代理的方法。（当然，可能还有其他更为简单、快捷的方法，希望知道的朋友能够分享、分享）</p>
<h2 id="参考文献">参考文献</h2>
<p>[1] <a href="https://www.jibing57.com/2020/05/31/how-to-speed-minecraft-launcher-on-macos/">在MacOS上加速Minecraft Launcher | Recording</a></p>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown常用语法</title>
    <url>/archives/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h3 id="背景">背景</h3>
<p>写这篇文章的目的是为记录在使用Markdown过程中经常用到，又时不时会忘记的一些语法，以及一些比较好的Markdown的用法，供日常查阅使用！（注意：本文没有完结的说法，会一直持续更新下去！）</p>
<span id="more"></span>
<h3 id="文献引用">文献引用</h3>
<p>通过<code>html</code>中的<code>&lt;div&gt;</code>标签给参考文献添加锚点，再利用<code>&lt;sup&gt;</code>标签在文章相应引用的段落进行标注<a href="#refer_anchor_1"><sup>1</sup></a>。</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">## Markdown 增加文献引用</span></span><br><span class="line"></span><br><span class="line">这边文章是介绍如何在 Markdown 中增加文献引用。[<span class="string">&lt;sup&gt;1&lt;/sup&gt;</span>](<span class="link">#refer-anchor-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="section">## 参考文献</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"refer-anchor-1"</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> [<span class="string">1</span>] [<span class="string">Markdown 添加文献引用</span>](<span class="link">https://blog.csdn.net/u012349679/article/details/103815049</span>)</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"refer-anchor-2"</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> [<span class="string">2</span>] [<span class="string">Wikipedia</span>](<span class="link">https://en.wikipedia.org/wiki/Main_Page</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="插入图片">插入图片</h3>
<p>插入指定大小的图片，并让图片居中，同样利用到了 <code>html</code> 语法</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片地址"</span> <span class="attr">style</span>=<span class="string">"zoom:50%"</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>注意这里利用到的是<code>css</code>的<code>zoom</code>选项，对图片整体进行缩放，如果要指定图片大小，可以用<code>img</code>标签的<code>width</code>和<code>height</code>属性</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">center</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"图片地址"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"400"</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>设置图片的宽为400，高为400，单位为pixels。</p>
<h3 id="参考文献">参考文献</h3>
<div id="refer_anchor_1">

</div>
<p>[1] <a href="https://blog.csdn.net/u012349679/article/details/103815049">Markdown 添加文献引用</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>to be continued</tag>
      </tags>
  </entry>
  <entry>
    <title>如何开启服务器的自定义端口？</title>
    <url>/archives/%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AB%AF%E5%8F%A3%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="背景">1 背景</h3>
<p>最近，和朋友一起玩mc，因为使用各种软件进行连接的效果都不是很理想，所以就想着干脆自己搭建一个mc的服务器，一是为了能够和朋友更方便和快乐的进行玩耍，二是正好借此机会检验一下自己的技术。</p>
<p>搭建mc服务器前面大部分的过程都十分顺利，一直到了最后一步，需要开启服务器的一个端口，向外部提供服务，无论怎么弄外部都无法对开启的端口进行访问（当时觉得十分纳闷服务器的端口分明就打开了呀？为什么外部就是无法访问呢？一度以为又是玄学），最后经过几个小时的“耐心”折腾终于解决了这个问题。</p>
<p>写这篇文章的目的就是为了记录开启服务器的一个自定义的端口，并能够让外部成功访问的一整个流程，因为在解决这个问题的过程中也在网上查找了大量的资料，发现很多朋友也和我遇到了同样的问题，但是网上都没有给出一个较为有效的解决方案，希望这篇文章能够帮助到有同样困惑的朋友们。</p>
<span id="more"></span>
<h3 id="开始之前">2 开始之前</h3>
<p>在文章开始之间先介绍一下这篇文章后续内容用到的一些工具以及相应的版本号：</p>
<ul>
<li><p>服务器（腾讯云：轻量应用服务器 CPU: 2核 内存: 2GB）</p></li>
<li><p><strong>操作系统</strong>（CentOS Linux release 7.6.1810 (Core)）</p></li>
</ul>
<p>需要重点关注的是所使用的操作系统以及相应的版本号，因为对于不同的操作系统，或者相同操作系统的不同版本，可能对于后面要介绍的一些方法会存在较大的差别，所以需要特别关注。但是好在不管用的工具是什么，方法的思路是相同的，只要掌握了方法思路，工具仅仅就是工具而已。</p>
<h3 id="正文部分">3 正文部分</h3>
<p>下面，正式开始进入这篇文章的主题，</p>
<h4 id="防火墙firewall">3.1 防火墙（firewall）</h4>
<p>想要开放服务器的指定端口，需要借助于服务器的防火墙。</p>
<h5 id="检测防火墙状态">3.1.1 检测防火墙状态</h5>
<p>首先需要确定的是当前服务器防火墙的状态，如果服务器的防火墙是关闭的，需要将它打开。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">systemctl status firewalld.service</span><br></pre></td></tr></tbody></table></figure>
<p>如果提示<code>Active: active (running)</code>：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since 六 2022-08-20 23:26:33 CST; 1 day 11h ago</span><br><span class="line">     Docs: man:firewalld(1)</span><br><span class="line"> Main PID: 6979 (firewalld)</span><br><span class="line">   CGroup: /system.slice/firewalld.service</span><br><span class="line">           └─6979 /usr/bin/python2 -Es /usr/sbin/firewalld --nofork --nopid</span><br></pre></td></tr></tbody></table></figure>
<p>说明服务器防火墙正常运行，那么就直接进行下一步。</p>
<p>如果提示<code>Active: inactive (dead)</code>：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">● firewalld.service - firewalld - dynamic firewall daemon</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/firewalld.service; disabled; vendor preset: enabled)</span><br><span class="line">   Active: inactive (dead)</span><br><span class="line">     Docs: man:firewalld(1)</span><br></pre></td></tr></tbody></table></figure>
<p>说明服务器防火墙处于关闭状态，那么需要开启服务器：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">systemctl start firewalld.service</span><br></pre></td></tr></tbody></table></figure>
<h5 id="开启端口">3.1.2 开启端口</h5>
<p>通过ssh进入服务器，借助于服务器的防火墙的<strong>命令行客户端（firewall-cmd）</strong>，可以开启服务器的指定端口。</p>
<p>下面以<strong>端口（2345）</strong>为例进行演示：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=2345/tcp --permanent</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>--zone=public：设置操作区域为public</li>
<li>--add-port：启用2345端口的TCP协议组合</li>
<li>--permanent：携带该参数表示永久配置，否则表示运行时配置</li>
</ul>
<p><strong>永久</strong>开启某个端口，需要重启防火墙才能让配置生效：</p>
<p>可以使用防火墙的<strong>命令行客户端（firewall-cmd）</strong>，重新加载防火墙规则并保存状态信息。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></tbody></table></figure>
<p>也可以使用systemd工具<strong>systemctl</strong>，重启防火墙</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></tbody></table></figure>
<p>接着，检查<strong>端口（2345）</strong>是否被成功开启：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --query-port=2345/tcp --permanent</span><br></pre></td></tr></tbody></table></figure>
<p>如果，显示是<code>yes</code>说明<strong>端口（2345）</strong>被成功开启，否则，说明开启失败。</p>
<h4 id="腾讯云服务器控制台">3.2 腾讯云服务器控制台</h4>
<p>由于本文使用的是腾讯云的轻量应用服务器，所以除了通过上面的方式开启服务器的端口之外，还需要在腾讯云提供的控制台上开启<strong>相应的端口（2345）</strong>，具体设置如下：</p>
<figure>
<img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/Obsidianimage-20220822141032700.png" alt="image-20220822141032700"><figcaption aria-hidden="true">image-20220822141032700</figcaption>
</figure>
<h4 id="启动端口对应的服务">3.3 启动端口对应的服务</h4>
<p>网上很多“教如何开启服务器端口”的教程都是到了3.2节就戛然而止了。</p>
<p>你说这样有问题吗？其实没有太大问题，因为“懂得人都懂”。</p>
<p>但是很多人就以为完成了3.2这一步之后就已经算是成功开启端口了（在之前我也是这样认为的），外部就可以对端口进行正常访问了。</p>
<p>可是实际上只完成3.2这一步，外部并不能正常访问端口，因为想要让外部能正常访问，还需要启动端口所对应的服务，即：要有程序对端口进行监听，这样当外部对端口进行访问时，监听该端口的程序才能做出正常的反馈。</p>
<p>就拿搭建的mc服务器来说，需要启动mc服务器程序去监听前面打开的<strong>端口（2345）</strong>，启动程序之后，通过<code>netstat</code>指令：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@VM-16-11-centos MineCraft]<span class="comment"># netstat -tunlp</span></span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp6       0      0 :::2345                 :::*                    LISTEN      17954/java</span><br></pre></td></tr></tbody></table></figure>
<p>可以查询端口和监听该端口所对应的程序，可以看到<strong>端口（2345）</strong>目前已经被PID为17954的java程序所监听。</p>
<p>到这一步，才算成功开启了服务器的<strong>端口（2345）</strong>，并能够供外部进行正常的访问。</p>
<h4 id="检测端口启动情况">3.4 检测端口启动情况</h4>
<p>可以在本地通过<strong>网络探测工具（nmap）</strong>，去检测服务器相应端口的启动情况：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">nmap -Pn IP地址 -p 端口号</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>-Pn</code>:禁用主机检测</li>
<li><code>-p</code>:指定端口号</li>
</ul>
<p>如果显示<strong>端口状态（STATE）</strong>为<code>open</code>：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Starting Nmap 7.92 ( https://nmap.org ) at 2022-08-22 12:09 CST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 124.223.166.235</span><br><span class="line">Host is up (0.050s latency).</span><br><span class="line"></span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">2345/tcp open  dbm</span><br></pre></td></tr></tbody></table></figure>
<p>则说明服务器的<strong>端口（2345）</strong>已经成功开启。</p>
<h3 id="总结">4 总结</h3>
<p>简单总结一下，其实现在回过头来冷静地、仔细地想，网上很多“教授开放服务器端口”的教程为什么到3.2节就结束也是有道理的。</p>
<p>因为服务器开放端口的目的就为了给外部提供某种服务，那既然要提供某种服务，自然需要相应的程序去监听和处理，</p>
<p>所以3.2节开放端口之后，启动端口想要给外部提供服务所对应的程序是一件十分自然的事情（“懂的人都懂”）</p>
<p>很多写教程的朋友可能都觉得这样事情不需要多提，但是对于小白（像我）可能当时就没有想到这点，惭愧，惭愧唔！</p>
<h3 id="参考文献">参考文献</h3>
<p>[1] <a href="https://cloud.tencent.com/developer/article/1691072">搞它！！！Linux--深入介绍firewalld防火墙管理工具 - 腾讯云开发者社区-腾讯云</a></p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>nmap</tag>
        <tag>netstat</tag>
        <tag>firewall-cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 使用“标准化”流程</title>
    <url>/archives/hexo-%E4%BD%BF%E7%94%A8%E2%80%9C%E6%A0%87%E5%87%86%E5%8C%96%E2%80%9D%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="背景">1 背景</h3>
<p>为了能够简单、高效、自由地分享一些技术文章，自己尝试过很多现有的博客框架，比如：Typecho，WordPress等等，但是二者均自己去搭建并维护服务器，用过一段时间之后发现，以自己目前的技术水平，维护服务器还是比较耗费精力的事情，这违背了自己做这件事情的初衷，还是希望把自己更多的精力专注到写作上来，所以最终选定了<code>Hexo + GitHub Pages</code>的方案假设个人博客。</p>
<p>Hexo 是一个快速、简洁且高效的博客框架，然后把服务器的维护工作交给GitHub，这样就能大大降低维护的成本，专注于文章创作。</p>
<p>写这篇文章的目的就是为了记录Hexo使用的一些“标准化”流程，一是为了防止自己以后忘记，二是为了规范操作，减少出错。</p>
<span id="more"></span>
<h3 id="hexo-常规操作">2 Hexo 常规操作</h3>
<p>首先，要进行下面的一系列操作需要先进到由Hexo所搭建的网站的文件夹中，不然可能无法识别相应的hexo指令。</p>
<h4 id="创建文章">2.1 创建文章</h4>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new <span class="string">"文章标题"</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>-p, --path</code>:自定义新文章的路径</li>
<li><code>-r, --replace</code>:如果存在同名文章，将其替换</li>
<li><code>-s, --slug</code>:文章的 Slug，作为新文章的文件名和发布后的 URL</li>
</ul>
<h4 id="清除缓存">2.3 清除缓存</h4>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></tbody></table></figure>
<p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h4 id="生成静态文件">2.2 生成静态文件</h4>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>-d, --deploy</code>:文件生成后立即部署网站</li>
<li><code>-f, --force</code>:强制重新生成文件，Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></li>
</ul>
<h4 id="部署网站">2.3 部署网站</h4>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>-g, --generate</code>:部署之前预先生成静态文件</li>
</ul>
<h3 id="参考资料">参考资料</h3>
<p>[1] <a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh 远程登录优化</title>
    <url>/archives/ssh-%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%E6%B5%81%E7%A8%8B%E7%AE%80%E5%8C%96/</url>
    <content><![CDATA[<h3 id="背景">1 背景</h3>
<p>我们使用<code>ssh</code>远程登录一个服务器时，一般都是直接使用输入密码的形式进行登录：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ssh -p 端口号 用户名@服务器ip地址 </span><br></pre></td></tr></tbody></table></figure>
<p>使用这种形式进行登录的缺点在于:<strong>容易有密码被暴力破解的问题</strong></p>
<p>当然针对于上面的这个问题，我们也有一些相应的应对策略：</p>
<ul>
<li>将 <code>ssh</code> 的端口设置为默认的 22 以外的端口</li>
<li>禁用 root 账户登录</li>
</ul>
<p>虽然上述策略能够对密码被暴力破解起到一定的防治作用，但是最好的解决办法还是通过<strong>密钥的方式</strong>进行登录。</p>
<p>这篇文章主要介绍如何通过<strong>密钥的方式</strong>进行<code>ssh</code>远程登录，然后进一步针对<code>ssh</code>登录流程进行优化，以求能够在保证足够安全的情况下，用最少的输入远程登录服务器。</p>
<span id="more"></span>
<h3 id="具体操作">2 具体操作</h3>
<p>具体的解决办法是<strong>通过密钥验证的方式，代替手动输入密码，登录远程服务器</strong>。</p>
<h4 id="生成公私钥文件">2.1 生成公、私钥文件</h4>
<p>通过使用OpenSSH认证密钥实用程序<code>ssh-keygen</code>可以生成公、私钥文件。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen [-t dsa | ecdsa | ecdsa-sk | ed25519 | ed25519-sk | rsa] </span><br></pre></td></tr></tbody></table></figure>
<p>其中，常用到的参数<code>-t</code>用来指定加密算法，通常使用<code>dsa</code>或<code>rsa</code></p>
<p>下面给一个生成公私、钥文件的实例：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">❯ ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/用户名/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /Users/用户名/.ssh/id_rsa</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /Users/用户名/.ssh/id_rsa.pub</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:70bmJt6sSEo+9AlT880IJCWBIufLX/pqdG3kS7xDZiE username@host</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 3072]----+</span></span><br><span class="line"><span class="string">|   .oo.          |</span></span><br><span class="line"><span class="string">|o o ...          |</span></span><br><span class="line"><span class="string">|.+   o           |</span></span><br><span class="line"><span class="string">|  .   E o        |</span></span><br><span class="line"><span class="string">| . . . XS=       |</span></span><br><span class="line"><span class="string">|  o = o %.=      |</span></span><br><span class="line"><span class="string">|   +.B.B *.      |</span></span><br><span class="line"><span class="string">|   o=oo.=++      |</span></span><br><span class="line"><span class="string">|   .++o.o*+      |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></tbody></table></figure>
<p>在上面的实例中可以看到，当没有指定加密的算法时，默认使用rsa作为加密算法。</p>
<p>注意，这里“密码”的英文单词是 passphrase，这是为了避免与 Linux 账户密码单词 password 混淆，表示这不是用户系统账户密码。</p>
<p>生成公、私钥文件的过程中会让回答几个问题：（可以直接按回车，表示采用默认选项）</p>
<ul>
<li>存放公、私钥文件的<strong>位置</strong>以及公、私钥文件的<strong>名称</strong>（默认：<code>/Users/用户名/.ssh/id_rsa</code>，这个是私钥的文件名，对应的公钥文件<code>/Users/用户名/.ssh/id_rsa.pub</code>是自动生成的）</li>
<li>是否要为私钥文件设定<strong>密码保护</strong>（passphrase），这样的话如果私钥文件不小心泄漏，也可以有密码保护。（默认：不设置）。</li>
</ul>
<p>最后，就会生成私钥和公钥，屏幕上会给出生成的<strong>公、私钥的存放位置及名称</strong>，还会给出<strong>公钥的指纹</strong>，以及<strong>当前的用户名（username）</strong>和主机名（host）作为注释，用来识别密钥的来源。</p>
<p>公钥文件和私钥文件都是文本文件，可以用文本编辑器看一下它们的内容。</p>
<p><strong>公钥文件</strong>的内容类似下面这样:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDQwg4vsQ+2UNCPcNJz6MN0RhOkKwFzuDzYr/lemZ6fck1SeVoEX8no5a75b6dFrEUjn47TB+oEq9pvS3W/w0SRdTiDnWgoPzoAlqCr9PDQaAA7zNPbOdIqksRcEZcCG3V/QN2RpgfQ+MiEs6vD/mTKjQfw0wg9iZfmkl5ARHBCxStIDxWpLqfwchH9h8xAtPYebfy+C70pkUKEJlsPQi3GgU7bV4W9OSzkxoT4XyTfo4isWV8oICokOs80Up+sTsgvMrDpGS3PS8BbzPZr1TwdpebzMW0CQrKe7l1rpO48cjEbPzX6fJ+9k6KL7pi1oxkIcILVzeZ5odm2jyhZ0Nx0Rycq8hYjaWI76SsKJHVhtcOvoDnnN99mq2dFJWxMDMGD9S7K5Oo5dk6lMngjIZTywIcdGssLChCodE37ys1TDmHewcC+0MDWma/8pz8IgJK25X50jNzQpGzSjPoXj8rVHN+Xe3GeT3GNO+s9BfnXB66ncWiV/kPRovSDfRH6WYk= username@host</span><br></pre></td></tr></tbody></table></figure>
<p>上面示例中，末尾的username@host是公钥的注释，用来识别不同的公钥，表示这是哪台主机（host）的哪个用户（username）的公钥，不是必需项。</p>
<p>注意，公钥只有一行，因为它太长了，所以上面可能分成三行显示。</p>
<h4 id="上传公钥">2.2 上传公钥</h4>
<p>为了能够实现密钥验证方式的远程登录，还需要将生成好的公钥上传服务器。（当然，也可以在服务器上生成公、私钥，将私钥传回本地。）</p>
<p>OpenSSH 规定，用户公钥保存在服务器的<code>~/.ssh/authorized_keys</code>文件。</p>
<p>你要以哪个用户的身份登录到服务器，密钥就必须保存在该用户主目录的<code>~/.ssh/authorized_keys</code>文件。</p>
<p>只要把公钥添加到这个文件之中，就相当于公钥上传到服务器了，每个公钥占据一行，如果该文件不存在，可以手动创建。</p>
<p>通过下面命令可以将公钥上传服务器（也可以手动进行上传）：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> ~/.ssh/id_rsa.pub | ssh user@host <span class="string">"mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys"</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面实例中，user@host要替换成所要登录的用户名和主机名。</p>
<p>注意，<code>authorized_keys</code>文件的权限要设为644，即只有文件所有者才能写。如果权限设置不对，ssh 服务器可能会拒绝读取该文件。</p>
<h4 id="配置ssh服务器config文件">2.3 配置ssh服务器config文件</h4>
<p>编辑服务器的<code>/etc/ssh/sshd_config</code> 文件，进行如下设置：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 禁用root账户登录，非必要，但为了安全性，可以选择配置</span></span><br><span class="line">PermitRootLogin no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否让 sshd 去检查用户家目录或相关档案的权限数据，这是为了担心使用者将某些重要档案的权限设错，可能会导致一些问题所致。例如使用者的 ~/.ssh/ 权限设错时，某些特殊情况下会不许用户登入</span></span><br><span class="line">StrictModes no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否允许用户自行使用成对的密钥系统进行登入行为，仅针对 version 2。至于自制的公钥数据就放置于用户家目录下的 .ssh/authorized_keys 内</span></span><br><span class="line">RSAAuthentication <span class="built_in">yes</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br><span class="line">AuthorizedKeysFile %h/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有了证书登录了，就禁用密码登录吧，安全要紧</span></span><br><span class="line">PasswordAuthentication no</span><br></pre></td></tr></tbody></table></figure>
<p>最后，重启 ssh 服务，使得配置生效：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></tbody></table></figure>
<h4 id="配置ssh客户端config文件">2.4 配置ssh客户端config文件</h4>
<p><code>ssh</code>除了命令行配置参数外，还可以通过配置文件来辅助管理，有两个级别的配置文件：</p>
<ul>
<li>用户级(user-specific file)：<code>~/.ssh/config</code>，通常不存在，如果需要自己新建</li>
<li>系统级(system-wide file)：<code>/etc/ssh/ssh_config</code>，内置有一些默认配置</li>
</ul>
<p>当需要管理多个远程服务器时，可以用配置文件进行管理，其格式如下：</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Host 服务器名A</span><br><span class="line">    user 用户名</span><br><span class="line">    hostname 服务器ip</span><br><span class="line">    port 端口号</span><br><span class="line">    identityfile 本地私钥地址（可选，默认：~/.ssh/id_dsa）</span><br><span class="line">    ...</span><br><span class="line">Host 服务器名B</span><br><span class="line">    user 用户名</span><br><span class="line">    hostname 服务器ip</span><br><span class="line">    port 端口号</span><br><span class="line">    identityfile 本地私钥地址（可选，默认：~/.ssh/id_dsa）</span><br><span class="line">    ...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">Host *</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure>
<h3 id="原理阐述">3 原理阐述</h3>
<p>通过密钥验证的方式进行远程登录主要的原理是利用了<strong>非对称密码算法</strong>，也被称为<strong>公钥算法</strong>。该算法使用一个秘钥（又被称为<strong>公钥</strong>）进行加密，用另外一个秘钥（又被称为<strong>私钥</strong>）进行解密。</p>
<p>常见非对称算法包括 RSA、SM2（国密）、DH、DSA、ECDSA、ECC 等。</p>
<h3 id="参考文献">4 参考文献</h3>
<p>[1] <a href="https://cloud.tencent.com/developer/article/1780788">Linux系列 | SSH 如何使用密钥登录服务器 - 腾讯云开发者社区-腾讯云</a></p>
<p>[2] <a href="https://www.jianshu.com/p/fab3252b3192">使用 SSH-Key 登录远程服务器 - 简书</a></p>
<p>[3] <a href="https://www.runoob.com/w3cnote/set-ssh-login-key.html">设置 SSH 通过密钥登录 | 菜鸟教程</a></p>
<p>[4] <a href="https://zj-network-guide.readthedocs.io/zh_CN/latest/ssh/%5BSSH%5D%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6config/">[SSH]客户端配置文件config - Network Guide</a></p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>你好像一位长辈！</title>
    <url>/archives/%E4%BD%A0%E5%A5%BD%E5%83%8F%E4%B8%80%E4%BD%8D%E9%95%BF%E8%BE%88%EF%BC%81/</url>
    <content><![CDATA[<p>下面这个今天和朋友的一段对话：</p>
<blockquote>
<ul>
<li><p>我：考上了吗？</p></li>
<li><p>朋友：没有，差一点</p></li>
<li><p>我：那找到调剂的学校了嘛？</p></li>
<li><p>朋友：没有，准备二战</p></li>
<li><p>我：那找好工作了嘛？</p></li>
<li><p>朋友：你好像一位长辈。。</p>
<p>......</p></li>
</ul>
</blockquote>
<span id="more"></span>
<p>朋友这句看似开玩笑的话，“你好像一位长辈。。”，突然警醒了我，让我不禁陷入了沉思：</p>
<p>“是呀，我是什么时候变成了这样？”</p>
<p>“看看我之前问的那些问题确实像一位长辈”</p>
<p>“难道每个人就应该按照所谓的一个既定轨迹去发展吗？”</p>
<p>是呀，不知道什么时候，自己也开始渐渐受到了既定思维的影响，在潜意识里开始认同或者认为，人就应该按照“小学-初中-高中-大学-读研-工作-买房-结婚...”这样的轨迹去发展，可是真的是这样吗？是谁规定的？到了一个特定的阶段就应该按照该阶段所谓的特定的事情去做？除此之外就没在有别的可能性了吗？</p>
<p>不，不是这样的，如果人人都按照上面所谓的既定的轨迹去生活，那么人还能称之为人吗？那样的人生还有意义吗？我觉得那更像一段不可修改的代码，一个冷冰冰的流水线。当然不可否认，那样的轨迹是我们大多数人的生活，我不能去说它好与不好，只不过我们应该允许例外的存在，能够去接受多样性，不能做一个活在套子里的人，用自己以为对的事情，去要求别人也那样，这样肯定是不好的。</p>
<p>我们应该允许并尊重每个人在自己人生的各个阶段做出属于自己的独特选择，而不是去问他们你以为，或者你自己定义的一个人生选择，这样只会给他们压力，或者引起他们的反感，而且做这样的人未免也太无趣了！</p>
<p>所以，以后这样的话还是留给“长辈”们去问吧，毕竟我只想做你的朋友！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>成长</tag>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title>远程会话管理工具:screen</title>
    <url>/archives/%E8%BF%9C%E7%A8%8B%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7screen/</url>
    <content><![CDATA[<h3 id="screen-是什么">1 screen 是什么</h3>
<p>screen通俗的说就是一个关于ssh的远程会话的管理工具。</p>
<h3 id="screen-有什么用">2 screen 有什么用</h3>
<ul>
<li>创建一个screen会话之后，即使中途ssh突然断开，在当前会话下执行的程序（或命令）也能够继续执行，不受影响</li>
<li>通过创建screen会话，其他人也可以进入创建的screen会话观察程序（或指令）的执行情况</li>
</ul>
<span id="more"></span>
<h3 id="screen-如何使用">3 screen 如何使用</h3>
<h4 id="screen会话的查询">3.1 screen会话的查询</h4>
<p>查看当前存在的哪些screen会话</p>
<blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">screen -list</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p>如果当前存在screen会话，就会显示：</p>
<p><img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/ObsidianObsidian20220405234416.png" style="zoom:80%;"></p>
<p>其中，30599是创建的screen会话的pid，demo是screen会话的名称，Detached是当前screen会话的状态，Detached表示当前会话没有人正在操作，还有另一个状态Attached，表示当前会话有人正在操作。</p>
<h4 id="screen会话的创建">3.2 screen会话的创建</h4>
<p>创建一个screen会话，通过<code>-S</code>选项可以指定要创建的screen会话的名称</p>
<blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">screen -S [screen会话名称]</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h4 id="暂时离开会话程序和指令继续执行">3.3 暂时离开会话（程序和指令继续执行）</h4>
<p>通过<kbd>ctrl a d</kbd>(按住<kbd>ctrl</kbd>，然后按<kbd>a</kbd>再按<kbd>d</kbd>)，可以暂时退出会话，但是会话中的程序会继续执行。（注意区分和后面退出会话的区别）</p>
<h4 id="screen会话的恢复">3.4 screen会话的恢复</h4>
<blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">screen -r screen会话的pid或screen会话的名称</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h4 id="screen会话的删除">3.5 screen会话的删除</h4>
<p>方法一：通过<code>screen -r</code>进入想要删除的screen会话，然后输入<kbd>exit</kbd>退出当前screen会话（会话中的程序不会在继续执行）</p>
<p>方法二：如果不能进入screen会话，通过<kbd>kill screen会话pid</kbd>将当前screen会话删除</p>
<h4 id="screen会话的共享">3.6 screen会话的共享</h4>
<p>其他人可以链接到远程服务器，通过<code>-x</code>选项观看当前screen会话正在执行的程序</p>
<blockquote>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">screen -x screen会话的名称或screen会话的pid</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<h3 id="参考资料">4 参考资料</h3>
<ul>
<li><a href="https://www.vpser.net/manage/screen.html">SSH远程会话管理工具 - screen使用教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>如何更好理解Peterson算法?</title>
    <url>/archives/%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%90%86%E8%A7%A3Peterson%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="peterson算法提出的背景">1 Peterson算法提出的背景</h1>
<p>在我们讲述Peterson算法之间，我们先了解一下Peterson算法提出前的背景（即：在这个算法提出之前，前人们都做了哪些工作）这对于我们之后理解Peterson算法有很大的裨益。</p>
<p>Peterson 算法是基于双线程互斥访问的LockOne与LockTwo算法而来。LockOne算法使用一个 flag 布尔数组，LockTwo 使用一个 turn的整型量，都实现了互斥，但是都存在死锁的可能。Peterson 算法把这两种算法结合起来，完美地用软件实现了双线程互斥问题。 <span id="more"></span></p>
<h1 id="peterson算法">2 Peterson算法</h1>
<p>首先，我们来看看下面这两段代码：</p>
<p></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">Pi进程：                                  </span><br><span class="line">flag[i] = True;</span><br><span class="line"><span class="keyword">while</span>(flag[j]);</span><br><span class="line">critical section;</span><br><span class="line">flag[i] = False;</span><br><span class="line">remainder section;</span><br></pre></td></tr></tbody></table></figure><p></p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">Pj进程：                                </span><br><span class="line">flag[j] = True;</span><br><span class="line"><span class="keyword">while</span>(flag[i]);</span><br><span class="line">critical section;</span><br><span class="line">flag[j] = False;</span><br><span class="line">remainder section;</span><br></pre></td></tr></tbody></table></figure>
<p>以上是用来实现两个进程互斥访问临界区的两端代码，我们可以这样来理解这两段代码，其中<code>flag[i]</code>表示进程Pi表示想要进入临界区，<code>while(flag[j])</code>可以理解为Pi在自己进临界区之前，先问问Pj是否想要进入临界区，如果Pj想进的话它就等待（Pi品德高尚）；类似的，Pj也是同样的。双方互相谦让的结果是，最终两个进程谁也进不了临界区。（可以想象这样一个生活场景，两个人同时想进屋，结果在门口谦让了了半天，过了很久都没进去）</p>
<p>Peterson算法就是在上面代码的基础之上，又引入了一个变量turn，打破了这种因为谦让而导致“饥饿”的现象。下面我们先来看看Peterson算法的代码：</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">Pi进程：                                  </span><br><span class="line">flag[i] = True;</span><br><span class="line">turn = j;</span><br><span class="line"><span class="keyword">while</span>(flag[j] &amp;&amp; turn == j);</span><br><span class="line">critical section;</span><br><span class="line">flag[i] = False;</span><br><span class="line">remainder section;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">Pj进程：                                  </span><br><span class="line">flag[j] = True;</span><br><span class="line">turn = i;</span><br><span class="line"><span class="keyword">while</span>(flag[i] &amp;&amp; turn == i);</span><br><span class="line">critical section;</span><br><span class="line">flag[j] = False;</span><br><span class="line">remainder section;</span><br></pre></td></tr></tbody></table></figure>
<p>怎么理解变量turn呢？可以将turn变量理解成轮到谁进入临界区了。举个例子：turn = i，表示轮到Pi进入临界区。那么上面这个代码就可以理解为：首先，Pi想进入临界区（<code>flag[i] = True</code>），然后，还是和前面的代码一样，Pi会先把进入临界区的机会让给Pj（<code>turn = j</code>），同样地，当Pj想进入临界区时，也会将进入临界区的权利先让给Pi。紧接着，变量turn的作用就显现出来了，当Pj把进入临界区的机会又让给Pi的时候（注意：这是发生在Pi将进入临界区的优先权让给Pj之后），Pi这次就会直接进入临界区。就不会再次出现一直互相谦让，最终导致均无法进入临界区的情况了。</p>
<p>关于为什么当进入临界区的权利（即turn = i）又回到Pi手里时，Pi会直接进入临界区的分析？我们可以分析一下Pi能够成功进入临界区的条件（即：while(flag[j] &amp;&amp; turn == j)语句）：</p>
<p>总的分为以下两种情况：</p>
<ol type="1">
<li><p>Pj不想进入临界区（flag[j] = False）</p>
<p>当Pj不想进入临界区时，自然也就不存在Pi和Pj冲突的情况，Pi当然就直接进入临界区。</p></li>
<li><p>Pj想进入临界区（flag[j] = True）</p>
<p>当Pj想进入临界区，又分为以下两种情况：</p></li>
</ol>
<ul>
<li><p>当 turn = i</p>
<p>turn = i说明当前轮到i进入临界区了 ，这个时候i就直接进入临界区了，不再谦让。（其实这个挺合理的，根据Peterson算法的代码我们不难发现因为turn的值是根据先后想要进入临界区的顺序排列的）</p></li>
<li><p>当 turn != i</p>
<p>turn != i 说明当前轮到i进入临界区了没有轮到Pi进入临界区，Pi自然需要等待。</p></li>
</ul>
<p>仅过上面的分析，我们就不难理解，当Pi和Pj经过一轮谦让之后，就会直接根据turn的值（即：该轮到谁进临界区了）来直接决定谁该进入临界区。现在回过头回顾整个算法，其实我们会发现，Peterson算法的思想会更贴近于生活中的真实情况，大家一般都是略微谦让一下，然后直奔主题，难道不是吗？哈哈</p>
<h1 id="参考资料">3 参考资料</h1>
<p>[1]维基百科编者. Peterson算法[G/OL]. 维基百科, 2021(20210501)[2021-05-01]. <a href="https://zh.wikipedia.org/w/index.php?title=Peterson算法&amp;oldid=65429794">https://zh.wikipedia.org/w/index.php?title=Peterson%E7%AE%97%E6%B3%95&amp;oldid=65429794</a>.</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>OS</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Word操作篇I-公式编辑</title>
    <url>/archives/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/</url>
    <content><![CDATA[<p><img data-src="https://raw.githubusercontent.com/Yapwn/BlogDataBase/master/ObsidianWord%E5%B0%81%E9%9D%A2%E5%9B%BE.jpg"> ## 1 背景</p>
<p>想必大家都遇到过要在Word中编辑公式的情况，当然，可能编辑公式还不是最难的，最难的可能是给公式编号吧，如何让公式自动根据章节号进行编号？如何让公式的编号与正文的右边对齐？对于能够熟练使用Word的人来说这些问题倒还好，但是不常使用Word的人来说，可能是挺困难的一件事情，下面就记录一下我的解决方案，一来是方便自己以后查阅（不然过一段时间就又忘记了），二来是给处于同样困境的朋友们一些参考。 <span id="more"></span> ## 2 预期效果</p>
<ul>
<li>实现公式根据章节自动编号以及交叉引用</li>
<li>实现公式编号于正文的右边对齐</li>
</ul>
<h2 id="工具">3 工具</h2>
<p>首先，先简单介绍了一下我进行下面操作用到的环境和工具：</p>
<ul>
<li>Windows 10 教育版（21H2）</li>
<li>MathType（7.4.4.516）</li>
<li>Word（2202）</li>
</ul>
<h2 id="具体操作">4 具体操作</h2>
<h3 id="公式自动号">4.1 公式自动号</h3>
<p>打开word，在word上端选项卡中选择Math Type这一项，点击插入编号-格式化，进行插入前的设置（比如：公式是根据章还是根据节编号等等）</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316170729209.png"></p>
<p>这里我们以公式按章节编号为例进行讲解，点击确认，就完成了设置。</p>
<p>然后，在插入公式栏中选择右编号，根据实际使用中插入公式的位置进行选择即可，点击确认，就可以进行公式输入。</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316171309471.png?token=ALWR22HTUSJDXCYIVEURMSTCGHWEY"></p>
<p>输入相应的公式之后，关闭输入窗口，就可以看到公式已经自动按照章节进行编号了。</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316171509274.png?token=ALWR22AHWWN4ENXQ6DSVCXDCGHWGC"></p>
<p>当当前章节公式编辑完毕，要进行下一章公式的编辑时，只需要在当前章插入分隔符（选择公式编号栏-章与节-插入分隔符-输入下一章的编号-确认），即可进行下一章公式的编辑：</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316172029370.png?token=ALWR22AUMX4E5FDS4OAVDO3CGHWG2"></p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316172122298.png?token=ALWR22AUMBV2TFL5YXSY3IDCGHWHE"></p>
<h3 id="公式的交叉引用">4.2 公式的交叉引用</h3>
<p>在需要插入公式的地方，选择公式编号栏-点击插入引用，点击确认。</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316172512421.png?token=ALWR22EE52C2KF5S2MMLYC3CGHWHU"></p>
<p>按照提示操作，找到需要插入的公式，双击该公式的编号，插入完成。</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316173056110.png?token=ALWR22CCGLLZD2G5GDIXG4DCGHWIA"></p>
<h3 id="公式编号与正文的右边对齐">4.3 公式编号与正文的右边对齐</h3>
<p>随便找到一个已经 插入的公式，选中编号-右键-点击段落-点击制表位，你会看到如下界面：</p>
<p>第一个参数，表示对公式的位置进行设置：</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316173828223.png?token=ALWR22ER6BEDYE2MSUMHK33CGHWIS"></p>
<p>第二个参数，表示对公式编号的位置进行设置：</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316174036926.png?token=ALWR22DRP553XJWBBPD44N3CGHWJA"></p>
<p>这时，我们只需要对第二个参数进行调整，就可以改变编号的位置，从而实现编号与正文的右侧对齐。</p>
<p>比如，我这里更改成30个字符，记得要将原来的39.52个字符那一项清除，点击确认。</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316174519594.png?token=ALWR22BWA3XGNL2V2RQ3XD3CGHWJO"></p>
<p>可以发现，图中编号(2-1)的位置发生了改变：</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316174844116.png?token=ALWR22GFJUTOUUO65UEMANDCGHWKK"></p>
<p>如果公式较多的话，可以选择将上述这个操作设置成样式，这样每次只要点击对应样式就可直接完成对齐操作：</p>
<p>在开始-样式一栏，选择创建样式，输入样式名称，点击修改：</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316175112579.png?token=ALWR22CDGAWJE6ETOXCWOMTCGHWK6"></p>
<p>在点击格式-选择制表位：</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316175334594.png?token=ALWR22GGB4H5N6MU6HX6NHTCGHWLW"></p>
<p>按照刚才的参数进行设置即可（这里不在赘述）：</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316175529553.png?token=ALWR22FCWGO2FMW2GLVFLSTCGHWL2"></p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316175604162.png?token=ALWR22HEOZZCLW5NIU72FSDCGHWMU"></p>
<p>设置好之后，我们随便找一个没有对齐的公式，选中该公式的编号点击我们刚才设置好的样式：</p>
<p><img data-src="https://raw.githubusercontent.com/CNMKYBW/BlogDataBase/master/Word%E6%93%8D%E4%BD%9C%E7%AF%87I-%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91/image-20220316175943588.png?token=ALWR22AVQ25V5GBWPWE5JMTCGHWNG"></p>
<p>可以发现编号（1-1）也同样实现了右对齐。</p>
<h2 id="后记碎碎念">5 后记（碎碎念）</h2>
<p>从上面的具体步骤我们可以发现word其实操作起来挺复杂的，就一个公式编号问题就要设置那么多东西，其实，我个人建议如果条件允许的话，能用Latex就尽量用Latex（当然也有避不开的情况...），那东西可是方便太多了，虽然上手有些难度，但是真的用顺手之后我相信你会爱上它的，后续我也会出一些关于Latex的教程，讲解一些Latex标签的基本用法，想了解的就关注一下。</p>
<p>emmm...这次就这样吧，再见！</p>
]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>office</tag>
        <tag>word</tag>
      </tags>
  </entry>
</search>
